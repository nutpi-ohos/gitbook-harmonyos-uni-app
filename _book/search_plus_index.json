{"./":{"url":"./","title":"1.前言","keywords":"","body":"前言 关注到目前很多人都很是关注uniapp For Harmony 于是集合坚果派的力量，利用业余时间写了这本入门的《鸿蒙版uniapp实战 》电子书并把它挂到网站上，希望能给读者带来一点帮助，也算为 OpenHarmony 和HarmonyOS以及整个大的鸿蒙生态的发展做一点贡献。 本书组织结构 本书采用循序渐进的学习路径，从 uniapp 与 OpenHarmony/HarmonyOS 的基础介绍出发，逐步深入到实际项目落地实践。全书共分为四篇，总计 8 章，各篇核心内容如下： 入门篇（第 1-2 章）：全面介绍 uniapp 与 OpenHarmony 的发展历程，帮助读者建立基础认知。 进阶篇（第 3-4 章）：深入讲解开发过程中的关键技术和进阶知识。 高阶篇（第 5-6 章）：聚焦 开发过程中的一些变更等 实战篇（第 7-8章）：通过多个实战项目，让大家了解uniapp/uniappx在OpenHarmony/HarmonyOS下的运行情况。 本书读者对象 本书适合具备一定编程基础和开发经验的读者，具体要求如下： 至少熟悉一门编程语言，建议掌握 JavaScript 或 ArkTS。 有移动端、Web 前端或 PC 端开发经验者优先。 由于本书内容具有一定深度，不适合编程零基础的初学者。 勘误 若您在阅读过程中发现任何错误或有改进建议，欢迎反馈。 致谢 在撰写本书的过程中，笔者主要参考了 OpenHarmony 和 uniapp 的官方文档以及 SDK 源码。期间，若发现问题，已及时在 OpenHarmony 相关仓库进行反馈。在此，感谢官方文档和源码的贡献者们。 powered by Gitbook该文件修订时间： 2025-06-29 08:32:08 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/1.为什么.html":{"url":"chapter2/1.为什么.html","title":"2.为什么要这个专栏？","keywords":"","body":"uni-app开发鸿蒙的核心价值与技术优势 跨平台开发 一次开发，多端发布：支持同时编译到鸿蒙、iOS、Android、Web等多平台 统一的API设计：减少平台差异带来的适配成本 条件编译机制：针对不同平台特性进行差异化实现 性能优化 接近原生体验：通过优化渲染管线提升运行效率 轻量级框架：减少运行时开销 原生组件支持：可无缝嵌入鸿蒙原生组件 开发者体验 熟悉的Vue语法：降低学习曲线 完善的工具链：HBuilderX提供一站式开发环境 热重载功能：提升开发效率 UTS语言支持：可直接调用鸿蒙原生能力 生态优势 庞大的uni-app开发者社区 丰富的插件市场资源 持续迭代更新，紧跟鸿蒙生态发展 powered by Gitbook该文件修订时间： 2025-05-19 14:40:53 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/15.优势.html":{"url":"chapter3/15.优势.html","title":"3.2优势","keywords":"","body":"uni-app 鸿蒙化优势 跨平台优势拓展 代码复用：uni-app 以 Vue.js 为基础，一套代码可多端编译运行。鸿蒙化后，开发者无需重复开发，即可适配安卓、iOS 和鸿蒙系统，提升开发效率。 新市场拓展：鸿蒙系统设备增长迅速，uni-app 鸿蒙化助开发者快速入局，扩大应用市场，增加商业机会。 快速开发与便捷调试 开发效率提升：uni-app 提供丰富 API、组件和模板，简化开发流程。HBuilderX 和 DevEco Studio 整合，助力开发者高效编码、调试。 热重载功能：uni-app x 在鸿蒙平台支持热重载，修改代码后无需重启应用即可查看效果，缩短开发周期。 充分利用鸿蒙系统特性 分布式能力：uni-app 鸿蒙化后，开发者可便捷调用鸿蒙分布式 APIs，实现设备协同，如多设备运动健康应用开发。 系统级服务调用：鸿蒙系统级服务如推送、定位、AI 服务等，uni-app 鸿蒙化后可直接调用，强化应用功能和用户体验。 应用性能优化 高性能渲染：uni-app x 在鸿蒙平台编译为 ArkTS 语言，利用 ArkUI 原生渲染引擎，实现高性能应用，带来流畅视觉体验。 优化工具：uni-app 提供性能分析工具，助力开发者优化应用性能，提升启动速度和运行流畅度，增强竞争力。 社区与生态支持 丰富资源：uni-app 拥有庞大社区，鸿蒙化后开发者可共享社区资源，如教程、插件、开源项目，加速应用开发，解决技术难题。 生态共建：uni-app 鸿蒙化使开发者参与到鸿蒙生态建设中，与各方共同完善生态，反馈需求和建议推动 uni-app 和鸿蒙优化改进。 powered by Gitbook该文件修订时间： 2025-05-19 14:11:26 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/1.uniapp开发鸿蒙应用.html":{"url":"chapter3/1.uniapp开发鸿蒙应用.html","title":"3.3uniapp开发鸿蒙应用","keywords":"","body":"今天带着大家一起uni-app for Harmony uni-app uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到HarmonyOS、iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/飞书/QQ/快手/钉钉/淘宝）、快应用等多个平台。 uni-app在开发者数量、案例、跨端抹平度、扩展灵活性、性能体验、周边生态、学习成本、开发成本等8大关键指标上拥有更强的优势。 功能框架图 HarmonyOS HarmonyOS 是新一代智能终端操作系统。 为不同设备的智能化、互联与协同提供了统一的语言。 设备可实现一碰入网，无屏变有屏，操作可视化，一键直达原厂服务等全新功能。 通过简单而智能的服务，实现设备智能化产业升级。 uni-app for Harmony 接下来我们以Mac电脑为例，开始今天的演示。 开发环境要求 DevEco Studio 5.0.1 Release 鸿蒙系统版本 API 12 以上 （DevEco-Studio有内置鸿蒙模拟器） HBuilderX-4.27+ 下载地址 大家先把上面两个工具安装配置好，这是最简单的，我们不过多阐释。操作完上面的步骤，我们就开始后面的内容。 Windows系统如使用模拟器则需要开启以下功能 打开控制面板 - 程序与功能 - 开启以下功能 Hyper-V Windows 虚拟机监控程序平台 虚拟机平台 注意: 需要win10专业版或win11专业版才能开启以上功能，家庭版需先升级成专业版或企业版 启动鸿蒙模拟器 连接鸿蒙真机 注意：真机需要鸿蒙系统版本 API 12 以上 打开鸿蒙手机开发者模式，开启USB调试，通过USB线连接电脑，在此处选择你的手机名称，再启动项目即可，如果提示需要先签名，则进行签名。 配置签名 点击 DevEco-Studio 上方菜单 File - Project Structure... 在弹出的窗体中选择 Project - Signing Configs 并打钩 Automatically generate signature，即可自动生成签名 配置 HBuilderX settings.json 打开HBuilderX，点击上方菜单 - 工具 - 偏好设置，在出现的弹窗右侧窗体新增如下配置。 { \"harmony.devTools.path\" : \"/Applications/DevEco-Studio.app/\" } 上面的报错就用下面的 { \"harmony.devTools.path\" : \"/Applications/DevEco-Studio.app/Contents/MacOS/devecostudio\" } 接下来就进入正题 配置 uni-app 工程 选择新建项目 HBuilderX 新建一个空白的 uniapp 项目，选vue3 编译 uni-app 到鸿蒙 点击 HBuilderX 上方【运行】菜单，运行到鸿蒙 DevEco Studio 在 DevEco-Studio 重新编译或运行 先等待 HBuilderX 编译完成，然后打开 DevEco-Studio，点击运行，下面这个报错是HBuilderX settings.json里的路径有问题，请检查。 然后重新启动 【首次运行】此时如果是第一次运行本项目会在项目根目录下生成harmony-configs目录用于存放鸿蒙配置文件。 【首次运行】配置签名信息、包名到鸿蒙配置文件内 项目的根目录下有一个 harmony-configs 目录，每当执行跟鸿蒙相关的操作时，HX 都会检查这个目录，如果目录不存在则会自动创建。 新版本（4.29+）还会检查与 HX 当前版本的内置鸿蒙工程模板是否匹配，如果版本不匹配（比如 HX 升级到新版本时）则会提示用户把需要更新的内容合并到目录中。 所有属于鸿蒙工程的配置调整，都可以写在 harmony-configs 目录下，具体内容可以参照鸿蒙的相关文档。其中常用内容有： 应用包名 在 harmony-configs/AppScrope/app.json5 中修改 app.bundleName 注意：HX 4.31+ 同时支持在项目的 manifest.json 里面以图形界面修改鸿蒙配置（包括包名），如果在那里做了设置，将优先于 harmony-configs/AppScrope/app.json5 里面的 app.bundleName。 运行权限 在 harmony-configs/entry/src/main/module.json5 中修改 module.requestPermissions 数字签名证书相关信息 在 harmony-configs/build-profile.json5 中修改 app.signingConfigs 证书签名配置指南 注意：配置签名需要先启动模拟器或连接真机后才能配置 点击 DevEco-Studio 上方菜单 File - Project Structure... 生成运行调试证书和签名 在弹出的窗体中选择 Project - Signing Configs，并打钩 Automatically generate signature，即可自动生成签名 不管是运行证书还是发布证书，生成的签名在文件 build-profile.json5 内 将它复制到你的 uni-app 项目根目录的 harmony-configs/build-profile.json5 的 signingConfigs 配置中 关于调试用的数字签名证书的配置 参考 申请调试证书 在使用模拟器进行调试运行的时候，一般是不需要做数字签名的，但如果是用真机进行调试运行，或者业务代码用到了 ACL 权限，那么就需要申请并配置一个调试证书用于数字签名。 数字签名证书需要配置到 harmony-configs/build-profile.json5 中，这个文件等同于一个普通的鸿蒙工程中对应的文件。 为了便于操作，可以用 DevEco Studio 创建一个简单的鸿蒙工程（注意设置好正确的应用包名 bundleName），在里面完成申请证书的操作， 具体方法可参考 自动签名， 然后把 build-profile.json5 文件中 app.signingConfigs 的内容复制到 harmony-configs/build-profile.json5 中。 通过 DevEco Studio 申请得到的证书，缺省会保存到电脑的用户目录下，在 Windows 系统中一般是 %USERPROFILE%\\.ohos\\config，在 Mac 系统中一般是 ~/.ohos/config。 配置信息中包含的三个文件缺省都是采用绝对路径来表示，也可以把这些文件移到 harmony-configs 目录下，这样就可以使用相对路径来表示，相对于 harmony-configs 目录。 如果要移动证书文件的位置，需注意跟这三个文件一起的还有一个名为 material 的目录，也要一起移动。 如何修改应用名称、图标、权限等信息 参考鸿蒙官方文档：应用/组件级配置 使用uts调用鸿蒙原生API uni-app在Android和iOS平台，支持uts插件和App原生语言插件。目前App原生语言插件已经停止维护。uts插件是主推的扩展方式。 鸿蒙系统有很多原生API，可以通过uts插件方式接入，被uni-app调用。大家可以期待一下后面的内容。 参考 什么是uni-app 开发指导 uts插件介绍 uts插件鸿蒙开发专题 uni-app官网文档已经支持转鸿蒙app的指导：https://uniapp.dcloud.net.cn/tutorial/harmony/dev.html 关于坚果派 坚果派社区由小波、狼哥等人创建，团队拥有26个华为HDE以及2700+HarmonyOS开发者，以及若干其他领域的三十余位万粉博主/UP专注于分享的技术包括HarmonyOS/OpenHarmony，仓颉、ArkUI-X，元服务，服务卡片，AI、BlueOS操作系统、团队成员聚集在北京，上海，南京，深圳，广州，苏州、长沙、宁夏等地，目前自研应用200款，三方库80个，鸿蒙原生应用课程500+。持续助力鸿蒙生态繁荣发展。社区地址：https://www.nutpi.net/ 加入坚果派，可以添加17752170152。 报错处理： 报错 未正确配置鸿蒙应用的包名 应该在 manifest.json 的【鸿蒙配置】中设置正确的包名，具体要求请参考 配置应用包名 报错 运行所需的权限没有签名授权 https://uniapp.dcloud.net.cn/tutorial/run/run-app-harmony.html#permissions-failed 报错 没有签名无法安装 当运行到鸿蒙时，如果选择真机为运行设备，则必须配置好数字签名证书，否则无法安装到真机上。 是把unpackage/debug里面的鸿蒙文件夹里面的文件都复制到harmony-configs文件夹里面吗 我只复制的4个文件：AppScope、entry、build-profile.json5、oh-package.json5，entry中的build没复制。如果需要其他文件也可以复制 这个是 harmony-configs/build-profile.json5 文件内容与新版本的鸿蒙工程模板不匹配导致的，删除 harmony-configs 目录和 unpackage 目录，然后重试。 hdc file recv /data/aiservice/config/config.json config.json hdc file send config.json /data/aiservice/config/config.json powered by Gitbook该文件修订时间： 2025-06-11 23:23:39 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/3.uniapp之uts语言.html":{"url":"chapter3/3.uniapp之uts语言.html","title":"3.4uniapp之uts语言","keywords":"","body":"uts 是什么 uts，全称 uni type script，是一门跨平台的、高性能的、强类型的现代编程语言。 它可以被编译为不同平台的编程语言，如： web平台/小程序，编译为JavaScript Android平台，编译为Kotlin iOS平台，编译Swift 鸿蒙OS平台，编译为ArkTS（HBuilderX 4.22+） uts 采用了与 ts 基本一致的语法规范，支持绝大部分 ES6 API。 但为了跨端，uts进行了一些约束和特定平台的增补。 过去在js引擎下运行支持的语法，大部分在uts的处理下也可以平滑的在kotlin和swift中使用。但有一些无法抹平，需要使用条件编译。 和uni-app的条件编译类似，uts也支持条件编译。写在条件编译里的，可以调用平台特有的扩展语法。 用途和关系 uts是一门语言。也仅是一门语言，不包含ui框架。 uvue是DCloud提供的跨平台的、基于uts的、使用vue方式的ui框架。 uts相当于js，uvue相当于html和css。它们类似于v8和webkit的关系，或者类似于dart和flutter的关系。 uts这门语言，有2个用途： 开发uni-app 和 uni-app x 的原生扩展插件：因为uts可以调用所有原生能力。 uts和uvue一起组合，开发原生级的项目，也就是 uni-app x 项目 从HBuilderX 3.9起，支持uni-app x项目。详见uni-app x 也就是说，uts可以在uni-app中使用，也可以在uni-app x中使用。 在uni-app中，主编程语言是js。uts可以开发原生插件，包括API插件和组件插件。 在uni-app x中，主编程语言是uts。不管是应用逻辑还是扩展插件，均使用uts编程。仅在Web平台和iOS的js驱动模式下可以使用js。 如果插件作者，开发了uts插件，也可以同时在uni-app和uni-app x中使用。比如这2个uts插件： 电量：https://ext.dcloud.net.cn/plugin?id=9295 lottie组件：https://ext.dcloud.net.cn/plugin?id=10674 这2个uts插件，一个是api插件，一个是组件插件，它们同时兼容uni-app和uni-app x。 可以通过表格更清晰的了解uts语言在uni-app和uni-app x下的编译关系。 uni-app uni-app x 普通页面和脚本 uts插件 普通页面和脚本 uts插件 Web和小程序 JS JS JS JS Android JS Kotlin Kotlin Kotlin iOS JS Swift JS(JS驱动时) Swift HarmonyNext JS ArkTS x x 这里的概念解释是： uts插件，指uni_modules目录下utssdk目录下的代码 除uts插件外，其他都属于 普通页面和脚本，包含vue、nvue、uvue等页面及单独的uts文件 在uni-app x的iOS平台，目前普通页面和脚本是编译为js的，而不是Swift。 这个策略主要是为了解决windows电脑开发uni-app x的问题。它并不影响性能，uni-app x的iOS通过优化解决了js性能问题。同时未来也会提供js驱动和Swift驱动双选 除了查阅表格，也可以简单的记3个原则： 所有的uts插件，都会编译为原生语言 web和小程序上，原生语言就是js App上，目前仅uni-app x的Android平台会编译为原生语言，其他都编译为js 本文是 uts 的基本语法介绍。 想了解 uni-app 下如何开发 uts插件，另见文档https://doc.dcloud.net.cn/uni-app-x/plugin/uts-plugin.html 想了解 uni-app x，另见文档https://doc.dcloud.net.cn/uni-app-x/ 类型声明 js是无类型的，TypeScript 的 type 就是类型的意思，给js加上了类型。它的类型定义方式是在变量名后面通过加冒号和类型来进行定义。 uts 中声明变量可以用 let 或 const，详见下。 变量定义（let） 声明一个可重新赋值的变量。语法 let [变量名] : [类型] = 值;。 相当于 TypeScript 中的 let、kotlin 中的 var、swift 中的 var。 let str :string = \"hello\"; // 声明一个字符串变量 str = \"hello world\"; // 重新赋值 类型除了 string 之外，更多类型见数据类型 常量定义（const） 声明一个只读常量，只能为其赋值一次。语法 const [变量名] : [类型] = 值;。 相当于 TypeScript 中的 const、kotlin 中的 val、swift 中的 let。 const str :string = \"hello\"; // 声明一个字符串常量 str = \"hello world\"; // 报错，不允许重新赋值 注意事项： 当前 uts 并未限制使用var来声明变量，但除非你知道你在做什么，否则不要轻易使用它，因为有不同平台差异： 编译至 JavaScript 平台时，等同于 JavaScript 平台的 var 。存在变量提升现象，具体参考 var和let的区别 编译至 Kotlin 平台时，等同于 Kotlin 平台的 var（允许重新赋值） swift 中 let 是定义常量，而 uts 和 ts 中，let 是定义变量。注意勿混淆。 类型定义的冒号，左右可以有一个空格，也可以没有空格。let str:string 和 let str : string 和 let str :string 和 let str: string 都是合法的。 变量命名规则 在 uts 中，使用变量名需要遵守一定的规则。 变量名称可以包含数字和字母。 除了下划线 _ 外，不能包含其他特殊字符，包括空格。 变量名不能以数字开头。 注意：与 TypeScript 不同的是，uts 不允许以 $ 开头命名变量 方法参数及返回值类型定义 方法的参数、返回值，也通过冒号定义。 如下示例，方法test，有一个参数score，是number类型，方法返回值类型为boolean类型。 function test(score: number): boolean { return (score>=60) } test(61) // 返回true 方法无返回值时，使用:void。 function add(x :string, y :string) :void { let z :string = x + \" \" + y console.log(z) // 不需要return } 函数另有详细文档，详见：函数 vue data类型定义 vue 选项式开发时，冒号被用于赋值，无法通过let、const和冒号来定义data数据的类型。 此时可以使用字面量赋值自动推导；也可以使用 as 关键字来显式声明类型。 export default { data() { const date = new Date() return { s1 : \"abc\", // 根据字面量推导为string n1 : 0 as number, // 这里其实可以根据字面量自动推导，as number写不写都行 n2, // 不合法，必须指定类型 n3 as number, // 不合法，uts不支持undefined，必须通过冒号初始化赋值，哪怕赋值为null，见下 n4 : null as number | null // 合法。定义为可为null的数字，初始值是null，但在使用n4前必须为其赋值数字。（number | null）是一个或的写法，前后顺序没有关系。uts的联合类型只支持 |null 。 year: date.getFullYear() as number, // 在data里，目前无法通过变量类型推导data项的类型，需使用 as 显式声明类型为number } } } 上述示例仅在 uni-app x 的uvue页面生效。老版uni-app，即js引擎版，不支持在页面里写uts代码，只支持在uts插件里写uts代码。 类型自动推导 现代语言（ts、kotlin、swift），都具备自动识别字面量，进行类型推导的功能。 即：如果开发者声明变量的同时，进行了初始化赋值。那么编译器可以根据赋值的字面量，自动推导出变量类型，不必开发者显式声明。 在定义变量时如果直接赋值字面量，而不使用冒号声明类型，也可以合法运行。 如下2种写法都是合法的，两个变量都是string类型： // 以下每组写法是等价的 let s1 = \"hello\" // 根据字面量 \"hello\"，自动推导为string类型 let s2 : string = \"hello\" let s3 : string s3 = \"hello\" let b1 = true // 根据字面量 true，自动推导为boolean类型 let b2 : boolean = true // 以上为字符串和布尔的字面量类型自动推导，数字和数组也支持字面量类型推导，但规则比较复杂，需另见文档 在HBuilderX 3.9以前， uts 未对字面量赋值类型推导做统一处理，编译到 kotlin 和 swift 时，由这2个语言自行做类型推导。 但 kotlin 和 swift 的自动推导，在某些地方有细节差异。尤其是数字字面量和数组字面量。在这2个场景下，建议显式声明类型，不使用自动推导。 // 显式声明数字和数组类型 let n1:number = 1 let n2 = 1 as number let n3:Int = 1 let a1:Array = [\"uni-app\", \"uniCloud\", \"HBuilder\"] let a1:Array = [1,2,3,4] 复制代码 HBuilderX 3.9+， uts 统一了字面量自动类型推导。 建议插件作者，除了boolean和string外，其他包括数字和数组在内的类型，尽量不使用字面量自动类型推导，而是显式声明类型。避免 uts 统一自动类型推导时引发的向下兼容问题。 类型判断 判断类型，有好几种方案：typeof、instanceof、isArray。 使用 typeof 可以判断布尔值、数字、字符串、函数。 typeof(true) == \"boolean\" typeof(\"abc\") == \"string\" let n1 : number = 1 typeof(n1) == \"number\" 复制代码 但如果使用 typeof 验证数组，会发现返回的类型值是\"object\"，这与浏览器是相同的逻辑。 如果想验证数组类型，需要使用如下方法： const a1 = [\"uni-app\", \"uniCloud\", \"HBuilder\"] console.log(Array.isArray(a1)) // 返回true console.log(a1 instanceof Array) // 返回true 复制代码 instanceof，除了验证数组，还可以验证类型，但注意它返回的不是具体类型，而是根据入参的一个boolean值。 let myDate = new Date(); console.log(myDate instanceof Date) // 返回true uni.request({ url: 'https://abc', success: (data) => { if (data.statusCode == 200) { const result = data.data as UTSJSONObject console.log(result instanceof UTSJSONObject) //返回true } }, fail: () => { console.log('fail'); } }); 详见：typeof、instanceof 安全调用 js没有类型检查。而uts和ts都有严格的类型检查。 对于可为null的类型，调用时需要加问号，否则编译器会报错。 const s: string | null = null // s为一个可为null的字符串 console.log(s?.length) //除非前面已经给s赋值，否则调用s的方法和属性必须加? 安全调用有很多细节，详见null类型 代码语句的分割 uts的多个代码语句，以回车或分号分割。 多行时行尾的分号可以省略。如果写在一行，应以分号分割。 如下的代码都是合法的： let a:number = 1 //行尾可以不加分号 let b:boolean = false; //行尾可以加分号 let c:number = 3 ; let d:number = 4 // 同行多语句需要用分号分割 powered by Gitbook该文件修订时间： 2025-05-19 14:09:46 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/4.uniapp for Harmony.html":{"url":"chapter3/4.uniapp for Harmony.html","title":"3.5uniapp for Harmony","keywords":"","body":"大家好，今天我们来到此系列的第四篇。 uniapp for Harmony 使用uts调用鸿蒙原生API uni-app在Android和iOS平台，支持uts插件和App原生语言插件。目前App原生语言插件已经停止维护。uts插件是主推的扩展方式。 鸿蒙系统有很多原生API，可以通过uts插件方式接入，被uni-app调用。 接下来我们一起来实践一下。 这里面我们分别从uts是什么开始讲起 什么是uts语言 uts，全称 uni type script，统一、强类型、脚本语言。 它可以被编译为不同平台的编程语言，如： web平台，编译为JavaScript Android平台，编译为Kotlin iOS平台，编译为Swift（HX 3.6.7+ 版本支持） HarmonyOS平台，编译为ArkTs（HX 4.22+ 版本支持）在现有架构下，ArkTs和JS在同一环境下执行，不涉及通讯等问题。 uts 采用了与 ts 基本一致的语法规范，支持绝大部分 ES6 API。 uts语言 可以用来开发独立App，即uni-app x； 也可以用来开发插件，即uts插件。 什么是uts插件 uts插件，指利用uts语法，操作原生的API（包括手机os的api或三方sdk），并封装成一个uni_modules插件，供前端调用。 uni-app中，是js来调用uts插件。 uni-app x中，是uts来调用uts插件。 也就是一个uts插件，可以同时支持uni-app和uni-app x。 为了兼容全端，uts插件可以分目录写所有平台代码，也就是一个uts插件除了支持App的扩展，还可以支持web、小程序。 比如这个uts插件，电量，其源码在https://gitcode.net/dcloud/uni-api/-/tree/master/uni_modules/uni-getbatteryinfo，内部有多个目录（app-android、app-ios、web、mp-weixin、mp-alipay...），在非App目录也可以写js。 这个电量插件在uni-app和uni-app x中均可以使用。 uts插件分api和组件。这和uni-app的组件、api的概念是一样的。 api插件：uts插件扩展了api能力，在script里调用 组件插件：uts插件扩展了界面组件，在template里调用。它是要内嵌在页面中。 api插件也可以操作界面，但更多是独立的全屏窗口或弹出窗口。而不能嵌入在template中。 uts插件与uni原生语言插件的区别 uts 插件编译到 app 平台时，在功能上相当于 uni-app 之前的 app 原生插件。都是给app扩展原生能力。 开发 uts 插件不需要熟悉 Kotlin 和 Swift 的语法，因为使用的是 uts语法。但需要熟悉 Android 和 iOS 的系统 API，至少需要知道什么原生能力在哪个API里。 在 HBuilderX 3.6 以前，uni-app 在 App 侧只有一种原生插件，即用 java 或 Objective-C 开发的插件。 在 uts 推出后，原来的 “App原生插件”，更名为 “App原生语言插件”。 不同的名字，代表它们需要开发者编写语言不同。但殊途同归，最后都编译为原生的二进制代码。 原生语言插件 uts插件 开发语言 java/oc uts 开发环境 Android Studio/XCode HBuilderX 打包方式 外挂aar 等产出物 编译时生成原生代码 js层调用方式 uni.requireNativePlugin() 普通的js函数/对象，可以直接 import，支持摇树优化 支持项目类型 uni-app uni-app和uni-app x 相对原生语言插件，uts插件的优势： 统一了编程语言（uts），一种语言开发所有平台，真正大前端。而且uts插件还支持鸿蒙next。而App原生只支持Android和iOS。 统一了开发工具（HBuilderX），免除搭建复杂的原生开发环境。 插件封装中要理解的概念更少。 传统原生语言插件需要在js和原生层处理通信，使用各种特殊转换，使用特殊语法导入，注意事项很多。uts统一为纯前端概念，简单清晰。 uts 下前端和原生可以统一在 HBuilderX 中联调，可以一起联编运行，可以把原生层信息打log到hx的控制台。而传统原生语言插件需要在多个开发工具间切换，联调复杂。 插件市场的uts插件支持下载后自己固定版本。而付费的原生语言插件只能使用最新版。 插件市场的uts付费插件支持源码版销售和源码版权保护机制。而付费的原生语言插件不支持源码版销售。 uts插件可同时支持uni-app和uni-app x。 如果您是插件作者，可以了解更多uts插件和uni原生语言插件对插件作者的区别。详见 创建uts插件 注意： 目前仅支持通过HBuilder X 创建和使用UTS插件，不支持通过cli的方式使用UTS插件 HBuilderX项目中uts插件目录结构 在 uni-app / uni-app x 的项目工程下，提供了独立的目录 utssdk，来存放 uts 插件。 当然官方更推荐使用 uni_modules 方式，这是更好的包管理方案。 首先确保项目根目录存在 uni_modules 文件夹，如果不存在，需要手动创建一个。 新建步骤拆解 右键点击uni_modules目录 -> 新建插件 选择类型 uts插件 为了避免和插件市场的其他插件冲突，建议起一个自己的插件前缀名称。 uts插件目录结构 package.json package.json 为 uni_modules 插件配置清单文件，负责描述插件的基本配置。 { \"id\": \"uts-helloworld\", \"displayName\": \"uts插件示例\", \"version\": \"0.1\", \"description\": \"uts插件示例\", \"uni_modules\": { } } 1.插件名字 2. package.json uni_modules加 \"uni-ext-api\": { \"uni\": { \"openAppProduct\": { \"name\": \"openAppProduct\", \"app\": { \"js\": false, \"kotlin\": false, \"swift\": false, \"arkts\": true } } } }, 3. interface.uts 直接复制，4. utssdk 新建app-harmony/index.uts 修改包名 这个步骤有问题嘛？ powered by Gitbook该文件修订时间： 2025-05-19 14:09:58 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/5.uniapp for Harmony FAQ.html":{"url":"chapter3/5.uniapp for Harmony FAQ.html","title":"3.6uniapp for Harmony FAQ","keywords":"","body":"我们在开发的过程中，或多或少会遇到一些开发方面的问题。 今天就来罗列一下 目录结构 一个uni-app工程，默认包含如下目录及文件： │─components 符合vue组件规范的uni-app组件目录 │ └─comp-a.vue 可复用的a组件 ├─utssdk 存放uts文件 ├─pages 业务页面文件存放的目录 │ ├─index │ │ └─index.vue index页面 │ └─list │ └─list.vue list页面 ├─static 存放应用引用的本地静态资源（如图片、视频等）的目录，注意：静态资源都应存放于此目录 ├─uni_modules 存放uni_module 详见 ├─platforms 存放各平台专用页面的目录，详见 ├─nativeplugins App原生语言插件 详见 ├─nativeResources App端原生资源目录 │ ├─android Android原生资源目录 详见 | └─ios iOS原生资源目录 详见 ├─hybrid App端存放本地html文件的目录，详见 ├─wxcomponents 存放小程序组件的目录，详见 ├─unpackage 非工程代码，一般存放运行或发行的编译结果 ├─main.js Vue初始化入口文件 ├─App.vue 应用配置，用来配置App全局样式以及监听 应用生命周期 ├─pages.json 配置页面路由、导航条、选项卡等页面类信息，详见 ├─manifest.json 配置应用名称、appid、logo、版本等打包信息，详见 ├─AndroidManifest.xml Android原生应用清单文件 详见 ├─Info.plist iOS原生应用配置文件 详见 └─uni.scss 内置的常用样式变量 uts语言在uni-app和uni-app x下的编译关系 uni-app uni-app x 普通页面和脚本 uts插件 普通页面和脚本 uts插件 Web和小程序 JS JS JS JS Android JS Kotlin Kotlin Kotlin iOS JS Swift JS(JS驱动时) Swift HarmonyNext JS ArkTS x x 条件编译仅 APP-HARMONY、APP 可以命中鸿蒙平台 现阶段条件编译仅 APP-HARMONY、APP 可以命中鸿蒙平台 // #ifdef APP-HARMONY console.log(\"仅鸿蒙会编译\") // #endif // #ifndef APP-HARMONY console.log(\"仅非鸿蒙会编译\") // #endif // #ifdef APP console.log(\"安卓、苹果、鸿蒙会编译，小程序和Web不会编译\") // #endif // #ifndef APP console.log(\"安卓、苹果、鸿蒙不会编译，小程序和Web会编译\") // #endif // #ifdef APP-PLUS console.log(\"安卓、苹果会编译，鸿蒙不会编译，小程序和Web也不会编译\") // #endif // #ifndef APP-PLUS console.log(\"安卓、苹果不会编译，鸿蒙会编译，小程序和Web也会编译\") // #endif 如何修改应用包名 打开 AppScope\\app.json5 修改 bundleName 如何修改应用名称 打开 AppScope\\resources\\base\\element\\string.json 修改数组元素 name 值为 app_name 对应的 value 的值 打开 entry\\src\\main\\resources\\base\\element\\string.json 修改数组元素 name 值为 EntryAbility_label 对应的 value 的值 打开 entry\\src\\main\\resources\\en_US\\element\\string.json 修改数组元素 name 值为 EntryAbility_label 对应的 value 的值 打开 entry\\src\\main\\resources\\zh_CN\\element\\string.json 修改数组元素 name 值为 EntryAbility_label 对应的 value 的值 如何修改应用图标 替换以下文件，注意文件不要改名 AppScope\\resources\\base\\media\\app_icon.png entry\\src\\main\\resources\\base\\media\\foreground.png entry\\src\\main\\resources\\base\\media\\startIcon.png 报启动鸿蒙失败，请手动启动鸿蒙 Windows系统 确保路径是正确的 注意：复制后的 \\ 要改成 / 如果步骤1操作完还是不行，请尝试 原路径后面添加 /bin/devecostudio64.exe，然后重启 HBuilderX Mac系统 确保路径是正确的（Mac系统快速复制路径方法按住option键） 如果步骤1操作完还是不行，请尝试原路径后面添加 /Contents/MacOS/devecostudio，然后重启 HBuilderX 通过 app-plus:titleNView 配置页面右上角按钮未生效 当前导航栏未支持，可以尝试关闭原生导航栏，使用自己的自定义导航栏组件实现。 注意事项 移植已有的 uni-app 项目源码时，如有其他 npm 依赖，请自行安装 现阶段条件编译仅 APP-HARMONY、APP 可以命中鸿蒙平台 每次HBuilderX改动源码后，DevEco-Studio 内需要点重新运行才能生效 如果模拟器白屏了，尝试重启软件 DevEco-Studio，再重启项目 如果模拟器无法连接了，尝试重启电脑 在HBuilderX里运行后，需要再去鸿蒙 DevEco Studio里运行 在HBuilderX里修改代码后，需要去鸿蒙 DevEco Studio里重新运行 如果有多个uni-app项目要编译到鸿蒙，那么鸿蒙离线sdk需要放置多份，每个uni-app的manifest中配置不同的离线sdk地址，否则会冲突，鸿蒙设备上目前没有基座概念。 以上开发问题参考：https://uniapp.dcloud.net.cn/tutorial/harmony/dev.html powered by Gitbook该文件修订时间： 2025-05-19 14:10:05 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/2.uniapp2.html":{"url":"chapter3/2.uniapp2.html","title":"3.7uniapp2","keywords":"","body":"真的昨天写完相关的文章以后，也是没想到，热度这么高，接下 uts for HarmonyOS 鸿蒙系统有很多原生API，这些API通过ArkTS来调用。 由于uts可以编译为ArkTS，所以uts可以调用鸿蒙的所有原生API。 如需在uni-app中使用，就需要把鸿蒙的原生API封装为uts插件，然后在uni-app中使用。 这些uts插件，是同时兼容uni-app和uni-app x的。 但目前仅uni-app支持鸿蒙next，uni-app x还需过段时间。 uni-app中开发者的逻辑是编译为js，js无法直接调用鸿蒙原生API。而uts插件是编译为ets文件，所以可以调用鸿蒙原生API。（ArkTS的文件后缀为.ets） 什么是uts语言 uts，全称 uni type script，统一、强类型、脚本语言。 它可以被编译为不同平台的编程语言，如： web平台，编译为JavaScript Android平台，编译为Kotlin iOS平台，编译为Swift（HX 3.6.7+ 版本支持） HarmonyOS平台，编译为ArkTS（HX 4.22+ 版本支持）在现有架构下，ArkTS和JS在同一环境下执行，不涉及通讯等问题。 uts 采用了与 ts 基本一致的语法规范，支持绝大部分 ES6 API。 什么是uts插件 uts插件，指利用uts语法，操作原生的API（包括手机os的api或三方sdk），并封装成一个uni_modules插件，供前端调用。 uni-app中，是js来调用uts插件。（HBuilderX 3.6支持vue3编译器，3.6.8支持vue2编译器） 1 了解 UTS 插件是什么 UTS 插件是 uni-app 扩展API的标准插件形式 uts插件在编译到HarmonyOS端时会被编译成ArkTS代码。因此编写代码时应注意遵循 uts规范 和 ets规范。 2 掌握UTS语法及ArkTS语法 无论是uts还是ArkTS都是在ts的语法基础上进行扩展来的。建议先阅读如下文档 typescript官方文档 uts语法 ArkTS约束 3 HarmonyOS 原生环境配置 参考：uni-app 开发鸿蒙应用 4 ArkTS 与 UTS 差异重点介绍 (持续更新) 类型差异 any类型 ArkTS内不能使用any类型，但是uts内any用处比较多，因此在编译为ArkTS时，any类型被转为了Object类型。 对象字面量 ArkTS不允许无类型的对象字面量，编写代码时应注意在需要类型时为对象字面量指定类型。如未指定类型，uts会将此对象字面量编译成as UTSJSONObject的形式。 // 源码 const obj = { a: 1 } // 编译结果 const obj = { a: 1 } as UTSJSONObject // 源码 interface Obj { a: number } const obj: Obj = { a: 1 } //或 const obj = { a: 1 } as Obj // 编译结果 class Obj { ... } const obj: Obj = { a: 1 } //或 const obj = { a: 1 } as Obj 5 常见问题 context的获取 很多HarmonyOS原生接口需要传入context作为参数。多数情况下可以直接调用HarmonyOS全局方法getContext()获取。例如： import settings from '@ohos.settings'; const context: Context = getContext(); settings.getValue(context, settings.display.SCREEN_BRIGHTNESS_STATUS, (err, value) => { if (err) { console.error(`Failed to get the setting. ${err.message} `); return; } console.log(`SCREEN_BRIGHTNESS_STATUS: ${JSON.stringify(value)}`) }); UTS 插件是 uni-app 扩展API的标准插件形式 详情 另见uts语法介绍 uts插件介绍 uts插件鸿蒙开发专题 powered by Gitbook该文件修订时间： 2025-05-27 11:34:21 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/6.uniappx支持鸿蒙.html":{"url":"chapter3/6.uniappx支持鸿蒙.html","title":"3.8uniappx支持鸿蒙","keywords":"","body":"uni-app x 支持鸿蒙 国产替代浪潮奔涌，鸿蒙适配已成为一个必答题，这里面跨端框架是破局多 OS 割裂的最优解。比如 uniapp x，之前有很多 app 可能是用 uniappx 做的，那么如何支持鸿蒙呢？ uni-app x 从4.61+起支持纯血鸿蒙，即Harmony NEXT。 uni-app x的鸿蒙版虽然是刚发布，但组件、API、CSS基本拉齐了Android和iOS。甚至还有扫码、拨打电话、剪贴板等超出Android/iOS的功能。 效果预览 开发环境要求 HBuilderX 4.61+，下载地址 鸿蒙电脑端开发工具DevEco Studio BuildVersion 5.0.11.100, 鸿蒙手机系统 API版本 14+，我这里是16. 运行和发行注意 uni-app x编译到鸿蒙是ArkTS语言，ArkTS在鸿蒙的ide deveco中没有热刷新。每次改动代码，需要重新build包、签名、安装新包到手机。 uni-app x在鸿蒙模拟器运行不受限制。 HBuilderX自身提供了运行、日志、debug、发行、调试证书申请等全套功能，开发者安装deveco后，可以做到不启动deveco，在HBuilderX中完成所有开发。 从 HBuilderX 4.61+ 开始支持通过配置指定使用特定的目录作为鸿蒙工程目录，这样就可以避免上述对于 uni-app 项目路径的额外限制了。 方法是在项目根目录下的 .hbuilderx/launch.json 中添加如下内容（如果该文件不存在则手动创建）： { \"version\" : \"1.0\", \"configurations\" : [ { \"type\" : \"uni-app:app-harmony\", \"distPathDev\" : \"D:/harmony-project-dev\", \"distPathBuild\" : \"D:/harmony-project-build\" } ] } 其中 distPathDev 用于指定调试运行的时候使用的鸿蒙工程目录，distPathBuild 用于指定发行打包的时候使用的鸿蒙工程目录。 指定的目录不必已经存在，HBuilderX 会创建所需的目录，如果目录已经存在的话 HBuilderX 还可能根据需要尝试删除然后重建。 HBuilderX 4.61+ 开始支持针对 uni-app x 项目的调试功能，支持断点调试，可以在控制台里面点击调试按钮开启。 证书签名配置指南 数字签名证书的配置最终需要落在鸿蒙工程根目录中的 build-profile.json5 文件中起作用。 从 HBuilderX 4.61+ 开始支持以交互方式配置相关信息（且支持自动申请调试证书），这些信息在构建阶段会被覆盖填写到鸿蒙工程的 build-profile.json5 文件中。 在 HBuilderX 里面直接配置证书签名 从 HBuilderX 4.61+ 开始支持这种配置方式。在【运行到鸿蒙】操作的【选择运行设备】对话框中，点击【配置调试证书】按钮，打开配置对话框 在 manifest.json 的编辑页面中，【鸿蒙App配置】里面也有打开配置对话框的按钮，分别用于配置调试证书和发布证书： 参考 HarmonyOS Uts调试 uniappx for HarmonyOS uniapp for HarmonyOS 坚果派 坚果派由坚果等人创建，团队拥有若干华为 HDE，以及若干其他领域的三十余位万粉博主运营。专注于分享的技术包括 HarmonyOS/OpenHarmony，ArkUI-X，元服务，服务卡片，华为自研语言，BlueOS 操作系统、团队成员聚集在北京、上海、广州、深圳、南京、杭州、苏州、宁夏等地。 聚焦“鸿蒙原生应用”、“智能物联”和“AI 赋能”、“人工智能”四大业务领域，依托华为开发者专家等强大的技术团队，以及涵盖需求、开发、测试、运维于一体的综合服务体系，赋能文旅、媒体、社交、家居、消费电子等行业客户，满足社区客户数字化升级转型的需求，帮助客户实现价值提升。 目前上架鸿蒙原生应用 18 款，三方库 72 个。欢迎大家加微信联系。 地址：https://atomgit.com/nutpi https://gitcode.com/nutpi powered by Gitbook该文件修订时间： 2025-05-19 14:10:14 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/7.uniapp-x支持鸿蒙.html":{"url":"chapter3/7.uniapp-x支持鸿蒙.html","title":"3.9uniapp-x支持鸿蒙","keywords":"","body":"uni-app x 从4.61+起支持Harmony NEXT 昨天的文章简单的带大家了解了一下uniapp支持鸿蒙 接下来一起看一下详细的介绍 uni-app x 是什么？ uni-app x，是下一代 uni-app，是一个跨平台应用开发引擎。 uni-app x 是一个庞大的工程，它包括uts语言、uvue渲染引擎、uni的组件和API、以及扩展机制。 uts是一门类ts的、跨平台的、新语言。 uts在iOS平台编译为swift、在Android平台编译为kotlin、在Web和小程序平台编译为js、在Harmony NEXT平台上编译为ArkTS。 在Android平台，uni-app x 的工程被整体编译为kotlin代码，本质上是换了vue写法的原生kotlin应用，在性能上与原生kotlin一致。 uts语言 开发者在 uni-app x 中，需使用 uts 而不是js。尤其是 Android端不自带js引擎，无法运行js代码。 uts 全称 uni type script，是一门跨平台的、高性能的、强类型的现代编程语言。它在不同平台，会被编译为不同平台的native语言，如： 它可以被编译为不同平台的编程语言，如： web平台/小程序，编译为JavaScript Android平台，编译为Kotlin iOS平台，编译Swift 鸿蒙OS平台，编译为ArkTS（HBuilderX 4.22+） ts 采用了与 ts 基本一致的语法规范，支持绝大部分 ES6 API。但为了跨端，uts进行了一些约束和特定平台的增补。 uvue渲染引擎 uts替代的是js，而uvue替代的就是html和css。或者如果你了解flutter的话，也可以理解为uts类似dart，而uvue类似flutter。 uvue是一套基于uts的、兼容vue语法的、跨平台的、原生渲染引擎。 Android版于3.99上线 Web版于4.0上线 iOS版于4.11上线 harmonyOS版于4.61上线 uvue渲染引擎包括uts版的vue框架（组件、数据绑定...）、跨平台基础ui、css引擎。 有了uvue，开发者就可以使用vue语法、css来快速编写页面，编译为不同平台的、高性能的纯原生界面。 uts和uvue uts是一门语言。也仅是一门语言，不包含ui框架。 uvue是DCloud提供的跨平台的、基于uts的、使用vue方式的ui框架。 uts相当于js，uvue相当于html和css。它们类似于v8和webkit的关系，或者类似于dart和flutter的关系。 uni的组件 uni-app x支持的组件包括： 内置基础组件：如view、text、image、scroll-view、input...等，详见组件清单 自定义vue组件：使用内置组件和vue组件技术进行封装的组件，支持easycom。 uts组件插件：用于原生sdk的ui以组件的方式嵌入。 API uni-app x支持的API包括： uts的API 详见 全局API，前面不需要加uni.。如getApp、getCurrentPages uni.xxx的内置API。数量较多，详见 uniCloud.xxx的内置API。详见 dom的API 详见 原生API 创建项目 或者 运行效果 组件 接口 css 模版 注意事项 最新版本运行的时候，会有这个问题，遇到这个问题，在源码模式删除 unipush以及 \"uni-verify\": {}, \"uni-facialVerify\": {} 题外话 不论鸿蒙还是开源鸿蒙目前整体处于发展的前期，能用，但是有坑，所以不能严格比照Android和iOS的验收标准要求鸿蒙。即便微信这样的应用，功能、质量也比不过Android/iOS版。 有空会继续更新关于uniapp for 鸿蒙的专栏，欢迎大家点赞，转发，谢谢大家。 参考 HarmonyOS Uts调试 uniappx for HarmonyOS uniapp for HarmonyOS 坚果派 坚果派由坚果等人创建，团队拥有若干华为 HDE，以及若干其他领域的三十余位万粉博主运营。专注于分享的技术包括 HarmonyOS/OpenHarmony，ArkUI-X，元服务，服务卡片，华为自研语言，BlueOS 操作系统、团队成员聚集在北京、上海、广州、深圳、南京、杭州、苏州、宁夏等地。 聚焦“鸿蒙原生应用”、“智能物联”和“AI 赋能”、“人工智能”四大业务领域，依托华为开发者专家等强大的技术团队，以及涵盖需求、开发、测试、运维于一体的综合服务体系，赋能文旅、媒体、社交、家居、消费电子等行业客户，满足社区客户数字化升级转型的需求，帮助客户实现价值提升。 目前上架鸿蒙原生应用 18 款，三方库 72 个。欢迎大家加微信联系。 地址：https://atomgit.com/nutpi https://gitcode.com/nutpi powered by Gitbook该文件修订时间： 2025-05-19 14:10:21 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/8.目前支持鸿蒙手机.html":{"url":"chapter3/8.目前支持鸿蒙手机.html","title":"3.10目前支持鸿蒙手机","keywords":"","body":"HarmonyOS 5 支持机型 大家在开发鸿蒙原生应用的时候，不知道哪些设备支持HarmonyOS 5 ，于是给大家整理一下，大家可以按需购买，直接去买二手的会更有性价比。 公测 手机 HUAWElPuraX HUAWEI Mate 70 Pro 优享版 HUAWEI nova 13 HUAWEI nova 13 Pro HUAWEI nova 12 HUAWEI nova 12 Pro HUAWEI Mate 70 HUAWEI Mate 70 Pro HUAWEI Mate 70 Pro+ HUAWEI Mate 70 RS | ULTIMATE DESIGN HUAWEI Mate 60 HUAWEI Mate 60 Pro HUAWEI Mate 60 Pro+ HUAWEI Mate 60 RS | ULTIMATE DESIGN HUAWEI Mate X6 HUAWEI Mate X6 典藏版 HUAWEI Mate X5 HUAWEI Mate X5 典藏版 HUAWEI Pura 70 HUAWEI Pura 70 北斗卫星消息版 HUAWEI Pura 70 Pro HUAWEI Pura 70 Pro+ HUAWEI Pura 70 Ultra HUAWEI Pocket 2 HUAWEI Pocket 2 艺术定制版 HUAWEI nova 12 Ultra HUAWEI nova 12 Ultra 星耀版 平板 HUAWEI MatePad Pro 13.2英寸 HUAWEI MatePad Pro 13.2英寸 典藏版 HUAWEI MatePad Pro 11英寸 2024款 花粉Beta 平板 HUAWEI MatePad Pro 12.2英寸 HUAWEI MatePad Air 12英寸 HUAWEI MatePad 11.5\"S HUAWEI MatePad 11.5\"S 灵动款 HUAWEI MatePad Pro 13.2英寸 2025 powered by Gitbook该文件修订时间： 2025-05-19 14:10:26 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/9.uniapp-x项目开发鸿蒙支持调试啦.html":{"url":"chapter3/9.uniapp-x项目开发鸿蒙支持调试啦.html","title":"3.11uniapp-x项目开发鸿蒙支持调试啦","keywords":"","body":"HBuilderX 4.61+ 运行到鸿蒙，支持Debug调试。包括uvue、uts、混编的ets都支持。 注意：鸿蒙调试，依赖鸿蒙调试插件，弹窗提示安装依赖插件，请务必点击安装，否则无法进行调试。 开启调试 如下图所示，运行uni-app x项目到鸿蒙，运行成功后，HBuilderX控制台点击红色虫子图标，下拉菜单选择【开启调试】，即可开启鸿蒙调试功能 打断点 打开要调试的uts、uvue、ets文件，在代码行号上，鼠标右击或双击添加断点。 调试视图 开启调试后，即可在HBuilderX左侧视图，看到调试视图，具体如下： 下图中包含了uvue、uts、ets的调试步骤 调试视图分为5部分: 调试工具栏 变量窗口 (复制值、复制表达式、添加到监视) 监视窗口（包含添加/编辑/删除表达式，以及复制值） 调用堆栈窗口 断点窗口（包含删除/启用/禁用断点） 调试操作 继续 F8 下一步 F10 进入 F11 返回 Shift+F11 数据检查和查看变量 添加到监视 在【变量窗口】，选中变量，右键菜单，即可将变量添加到监视窗口。 悬停显示 断点调试过程中，将鼠标悬停在要查看的变量上，即可打开悬停窗口。 powered by Gitbook该文件修订时间： 2025-04-15 13:40:27 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/10.uniapp和flutter你会选哪个来开发鸿蒙.html":{"url":"chapter3/10.uniapp和flutter你会选哪个来开发鸿蒙.html","title":"3.12uniapp和flutter你会选哪个来开发鸿蒙","keywords":"","body":"uniapp 与 Flutter 的差异 Flutter Flutter 是一个由 Google 推出的移动应用开发框架，使用 Dart 语言编写。Flutter 具有高度的可定制性和丰富的 UI 组件，它使用自有的渲染引擎和框架，可以在多个平台上实现快速、高效的应用程序开发。 Flutter鸿蒙化的优点： 快速迭代和发布：Flutter 的热重载功能允许开发人员在进行更改后即时看到结果，这大大缩短了开发时间。 丰富的 UI 库：Flutter 内置了许多美观且高性能的 UI 组件，允许开发人员轻松创建复杂的用户界面。 卓越的性能：Flutter 通过自有的渲染引擎，可以在多个平台上实现高性能的应用程序。 目前提供了3.22和3.7版本的支持，三方库也适配了蛮多，即使没有适配大家也可以根据适配指导自己适配。 Flutter鸿蒙化 缺点： 需要学习新的编程语言：使用 Flutter 开发应用程序需要学习 Dart 编程语言，这可能需要一些额外的时间和资源。 相对较小的开发社区：相对于 uniapp，Flutter 的开发社区相对较小，但是现在有了ai的帮助，开发者们遇到问题，也可以用ai，快速定位。 uniapp uniapp 是一个由 DCloud 推出的基于 Vue.js 开发的跨平台应用程序开发框架，可以同时支持 Android 和 iOS ，鸿蒙等多种平台。uniapp 通过使用原生组件，提供了与原生应用程序相似的用户体验。 uniapp 优点： 易于使用：开发人员可以使用熟悉的 Vue.js 框架来构建应用程序，这使得学习和使用 UniApp 相对容易。 基于原生组件：uniapp 使用原生组件来实现应用程序的功能，这使得应用程序具有更好的性能和用户体验。 适用于小型应用程序：uniapp 适用于构建小型应用程序，小程序等。 目前uniapp和uniapp-x都支持开发鸿蒙 uniapp 缺点： 缺乏扩展性：uniapp 的功能相对较少，如果需要添加一些高级功能，可能需要自己编写原生代码。 目前uniapp和uniapp-x虽然都支持开发鸿蒙，但是生态没有鸿蒙版flutter完善。 学习成本的对比感悟 1. 开发语言的不同 Flutter，要求开发者学习dart，了解dart和flutter的API，最好还会写点原生~而uni-app只需要学Vue.js，没有附加专有技术。所以从学习一个框架来看，很明显uni-app的学习成本很低。 2. 第三方插件&社区氛围 截至目前2025.4月，flutter在github上有170K的star，uni-app有着40K的star。从star的数量也可以看出一个框架的热度，很明显，flutter是远高于uni-app的。对于第三方插件呢Flutter有着pub.dev，uni-app有插件市场，但相比Flutter还是有出入的。 3. 开发工具的使用 Flutter可以选择vscode或者android studio等来进行开发，uni-app可以选择HBuilderX，当然也可以使用vscode，用什么开发工具其实大差不差。 编码实现对比 1. 布局区别 代码整体结构：Flutter使用Widget层级嵌套来构建用户界面，也是被很多人所不喜欢的嵌套地狱。 uni-app 使用 Vue.js 的组件化布局方式，template、style 和 script。template 定义了组件的 HTML 结构，style 定义了组件的样式，script 定义了组件的行为。 布局原理区别：Flutter 中的布局是基于约束的，可以使用Constraints来控制小部件的最大和最小尺寸，并根据父级小部件的约束来确定自身的尺寸。uni-app则是，可以使用类似于 CSS 中 Flex 弹性布局的方式来控制组件的排列和布局。通过设置组件的样式属性，如 display: flex、flex、justify-content等，可以实现垂直和水平方向上的灵活布局。当然flutter也有和flex差不多的row与column。 自定义布局：Flutter支持自定义布局，可以通过继承 SingleChildLayoutDelegate 或 MultiChildLayoutDelegate 来实现自定义布局，而uni-app目前并没有直接提供类似的专门用于自定义布局的机制，不过uni-app常见的做法是创建一个自定义组件，并在该组件的 template 中使用各种布局方式、样式和组件组合来实现特定的布局效果。 2. 状态管理的区别 Flutter 提供了内置的状态管理机制，最常见的就是通过setState来管理小部件的状态，uni-app是利用Vue.js的响应式数据绑定和状态管理，通过 data 属性来定义和管理组件的状态。 3. 开发语言的区别与联系 区别：众所周知，JavaScript 是一门弱类型的语言，而 Dart 是强类型的语言。Dart有类和接口的概念。 powered by Gitbook该文件修订时间： 2025-05-20 08:38:35 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/12.uniapp版本更新.html":{"url":"chapter3/12.uniapp版本更新.html","title":"3.14uniapp版本更新","keywords":"","body":"HBuilder4.62发布，修复多个鸿蒙bug 大家在之前的文章应该看到了，关于HBuilder4.61版本的一些bug，新的版本目前已经解决这个问题 本次修改在鸿蒙上的体现主要有： uni-app App-Harmony平台 新增 defineNativeEmbed 接口，用于定义原生嵌入组件 详情 App-Harmony平台 修复 getStorage 接口返回的对象内的数组调用 push 方法无效的Bug 详情 App-Harmony平台 修复 uts 插件内打印日志无法在 HBuilderX 控制台查看的Bug uni-app x App-Harmony平台 新增 运行调试 支持运行到 x64 平台的鸿蒙模拟器 详情 uts插件 App-Harmony平台 修复 UTSHarmony 在较早时机无法调用 getUIAbilityContext 的 Bug 详情 其他的更新可以查看具体的更新日志。 powered by Gitbook该文件修订时间： 2025-05-19 14:10:42 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/13.HBuilderX 4.62 开始，uni-app 支持嵌入鸿蒙原生组件.html":{"url":"chapter3/13.HBuilderX 4.62 开始，uni-app 支持嵌入鸿蒙原生组件.html","title":"3.15HBuilderX 4.62开始，uni-app支持嵌入鸿蒙原生组件","keywords":"","body":"HBuilderX 4.62 开始，uni-app 支持嵌入鸿蒙原生组件 uni-app 组件难以应对之处，鸿蒙原生组件方显其能。 从 uni-app 4.62 版本起，开发者可以通过 UTS 插件将鸿蒙原生组件嵌入到 uni-app 应用中，并且支持同层渲染。这一功能使得开发者能够充分利用鸿蒙系统的原生组件，提升应用的性能和用户体验。以下是具体介绍和实际案例。 嵌入鸿蒙原生组件 鸿蒙系统提供了丰富的原生组件，这些组件可以通过 UTS 插件注册为 WebView 支持的原生组件。目前，鸿蒙原生组件仅支持定义在 ETS 文件中，UTS 插件支持导入 ETS 文件，从而实现原生组件在 uni-app 中的嵌入。 例如，在页面中嵌入原生的 button、map 等组件，具体实现方式可参考uni-app 官方文档。 实际案例：使用华为花瓣地图 接下来，我们将通过一个实际案例，展示如何在 uni-app 中嵌入华为花瓣地图。 效果展示 代码实现 Template 部分 Script 部分 import \"@/uni_modules/native-harmony-map\"; export default { data() { return { options: { latitude: 22.5431, longitude: 114.0579, scale: 12, circles: [ { latitude: 22.5431, longitude: 114.0579, color: 0xffff0000, // 圆形边框颜色 fillColor: 0xff00ffff, // 圆形填充颜色 radius: 80, // 圆形半径，单位：米 strokeWidth: 10, // 圆形边框宽度，单位：像素 }, ], markers: [ { latitude: 22.5431, longitude: 114.0579, }, ], }, }; }, methods: { onMarkerTap(e) { console.log(\"onMarkerTap\", e); uni.showToast({ title: `点击了标记点 ${e.detail.markerId}`, icon: \"none\", }); }, }, }; Style 部分 .container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; padding: 20px; box-sizing: border-box; } .map-container { width: 100%; height: 70%; margin-bottom: 20px; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); } .native-map { width: 100%; height: 100%; } 完整代码 import \"@/uni_modules/native-harmony-map\"; export default { data() { return { options: { latitude: 22.5431, longitude: 114.0579, scale: 12, circles: [ { latitude: 22.5431, longitude: 114.0579, color: 0xffff0000, fillColor: 0xff00ffff, radius: 80, strokeWidth: 10, }, ], markers: [ { latitude: 22.5431, longitude: 114.0579, }, ], }, }; }, methods: { onMarkerTap(e) { console.log(\"onMarkerTap\", e); uni.showToast({ title: `点击了标记点 ${e.detail.markerId}`, icon: \"none\", }); }, }, }; .container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; padding: 20px; box-sizing: border-box; } .map-container { width: 100%; height: 70%; margin-bottom: 20px; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); } .native-map { width: 100%; height: 100%; } 优化与总结 优化建议 性能优化 ：在使用原生组件时，注意组件的性能表现，避免过度使用复杂的原生组件导致应用性能下降。 用户体验 ：确保原生组件与 uni-app 的其他部分在视觉和交互上的一致性，提供流畅的用户体验。 兼容性测试 ：在不同设备和鸿蒙系统版本上进行充分的兼容性测试，确保应用的稳定性和功能完整性。 代码复用 ：将常用的原生组件封装成可复用的模块或插件，提高开发效率。 总结 HBuilderX 4.62 开始，uni-app 对鸿蒙原生组件的支持为开发者提供了更广阔的空间来构建高性能、功能丰富的应用。通过 UTS 插件，开发者可以轻松地将鸿蒙原生组件嵌入到 uni-app 应用中，充分利用鸿蒙系统的特性。未来，随着 uni-app 和鸿蒙系统的不断发展，我们有理由相信，这种结合将为开发者带来更多的创新机会和可能性。 开源项目地址 https://gitcode.com/nutpi/uniapp-harmony-map 参考 UTS 语法 UTS API 插件 UTS uni-app 兼容模式组件 UTS 标准模式组件 Hello UTS uniapp 嵌入鸿蒙原生组件 调用鸿蒙原生 API uniapp 同层渲染调用华为花瓣地图 坚果派 坚果派由坚果等人创建，团队拥有若干华为 HDE，以及若干其他领域的三十余位万粉博主运营。专注于分享的技术包括 HarmonyOS/OpenHarmony，ArkUI-X，元服务，服务卡片，华为自研语言，BlueOS 操作系统、团队成员聚集在北京、上海、广州、深圳、南京、杭州、苏州、宁夏等地。 聚焦“鸿蒙原生应用”、“智能物联”和“AI 赋能”、“人工智能”四大业务领域，依托华为开发者专家等强大的技术团队，以及涵盖需求、开发、测试、运维于一体的综合服务体系，赋能文旅、媒体、社交、家居、消费电子等行业 目前上架鸿蒙原生应用 40款，三方库 80个。欢迎大家加微信联系。 地址：https://atomgit.com/nutpi https://gitcode.com/nutpi 官网：https://www.nutpi.net/ powered by Gitbook该文件修订时间： 2025-05-27 05:18:14 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/16.uni-app x 已经完成鸿蒙等主流平台全覆盖.html":{"url":"chapter3/16.uni-app x 已经完成鸿蒙等主流平台全覆盖.html","title":"3.16uni-app x 已经完成鸿蒙等主流平台全覆盖","keywords":"","body":"uni-app x：开启全平台原生开发新时代 在2025年数字技术发展的关键节点上，国产操作系统正在经历从愿景走向现实的深刻变革。DCloud于5月12日发布的HBuilderX4.64正式版，标志着uni-app x已实现对鸿蒙、Android、iOS、Web、微信小程序等主流平台的全覆盖，为开发者带来了全新的跨平台开发体验。 一、技术革新：Web技术栈与原生性能的完美融合 uni-app x的突破性在于其独特的设计理念：“开发态基于Web技术栈，运行时编译为原生代码”。开发者可以继续使用熟悉的Vue语法与类TypeScript的UTS语言构建项目，而当编译至鸿蒙平台时，代码将被转换为鸿蒙NEXT的原生语言ArkTS，并基于ArkUI引擎运行。这种架构实现了： 编译原生化：直接编译为ArkTS，无中间层损耗 渲染原生化：使用原生组件与渲染引擎 跨平台统一API：封装网络、文件系统、多媒体等基础能力 零延迟架构：逻辑层与视图层共享原生进程，避免跨语言通信延迟 这种设计让开发者既能享受Web技术栈的开发效率，又能获得媲美原生应用的性能体验。 二、与传统uni-app的差异化定位 特性对比 uni-app uni-app x 架构模式 HybridApp架构 语言翻译架构 渲染方式 WebView渲染 原生组件+原生渲染 性能表现 适合中低性能需求 高性能场景最优选 鸿蒙适配方式 Webview容器适配 原生代码转换 uni-app x更适合对性能体验有更高要求的开发者，特别适用于游戏、图形渲染、复杂交互等场景。 三、解决传统跨平台框架痛点 在当前技术环境下，开发者面临多平台开发的困境： 单平台开发成本高且难以维护 Flutter等框架存在性能瓶颈 鸿蒙系统缺乏官方跨平台支持 跨平台框架普遍存在原生能力调用延迟 uni-app x通过以下方式解决了这些痛点： 原生性能：直接编译为原生代码，无JS引擎和WebView渲染 原生API直连：无需插件封装即可调用系统原生API 生态扩展性：拥有数千款支持鸿蒙next的插件 平滑迁移路径：与传统uni-app项目保持高度兼容性 四、国产操作系统的战略意义 鸿蒙系统的适配已经从\"做不做\"的讨论，转变为\"如何高效做\"的实践阶段。uni-app x作为连接开发者与国产操作系统的桥梁，通过以下方式助力技术转型： 降低迁移成本：传统Web/uni-app项目可低成本迁移至鸿蒙平台 提升开发效率：一套代码实现多端运行，减少重复开发工作 保障性能体验：原生性能确保应用在各平台的流畅体验 促进生态繁荣：丰富的插件市场加速应用功能扩展 五、行业展望 随着国产操作系统的逐步普及，跨平台开发工具正在经历代际升级。uni-app x的出现，标志着开发工具从\"跨平台兼容\"向\"原生性能+全平台覆盖\"的进化。对于开发者而言，这不仅是一个技术工具的更新，更是参与国产操作系统生态建设的历史机遇。 在这个技术变革的时代，uni-app x凭借其创新架构，正在重新定义跨平台开发的边界，为开发者提供了兼具效率与性能的全新选择。 我认为对中小企业还是有吸引的。不过这次发现个问题。这次Alpha版比正式版更新频率低了，大家知道为啥吗？欢迎在评论区交流。 链接 下载 uniapp学习资料 uni-app x 正式支持鸿蒙原生应用开发 完毕 powered by Gitbook该文件修订时间： 2025-05-19 14:20:10 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/17.uniapp如何进行条件编译到鸿蒙.html":{"url":"chapter3/17.uniapp如何进行条件编译到鸿蒙.html","title":"3.17uniapp如何进行条件编译到鸿蒙","keywords":"","body":"uni-app 鸿蒙平台条件编译指南 在 uni-app 开发中，针对不同平台进行条件编译是一项重要技能。尤其是对于鸿蒙平台，合理运用条件编译可以优化代码，实现平台差异化功能。以下是针对鸿蒙平台的条件编译规则及示例详解： 一、条件编译指令 APP-HARMONY ：仅在鸿蒙平台编译时命中，用于编写鸿蒙平台专属代码。 APP ：安卓、苹果、鸿蒙平台会编译，小程序和 Web 平台不会编译，适用于多端（非小程序和 Web）通用代码。 APP-PLUS ：安卓、苹果平台编译时命中，鸿蒙、小程序和 Web 平台不会命中，主要针对安卓和苹果特定功能。 二、代码示例及说明 // #ifdef APP-HARMONY console.log(\"仅鸿蒙会编译：这里编写鸿蒙平台专有功能代码\") // #endif // #ifndef APP-HARMONY console.log(\"仅非鸿蒙会编译：此处代码在安卓、苹果、小程序和 Web 平台生效\") // #endif // #ifdef APP console.log(\"安卓、苹果、鸿蒙会编译，小程序和 Web 不会编译：适合多端共用的非小程序和 Web 功能\") // #endif // #ifndef APP console.log(\"安卓、苹果、鸿蒙不会编译，小程序和 Web会 编译：用于小程序和 Web 平台的特定功能\") // #endif // #ifdef APP-PLUS console.log(\"安卓、苹果会编译，鸿蒙、小程序和 Web 不会编译：实现安卓和苹果平台的特定功能\") // #endif // #ifndef APP-PLUS console.log(\"安卓、苹果不会编译，鸿蒙、小程序和 Web 会编译：非安卓和苹果平台的代码逻辑\") // #endif 三、注意事项 正确使用条件编译指令可以提升代码的可读性和可维护性，避免不必要的代码冗余。 在进行条件编译时，要注意各平台的特性差异，确保代码在目标平台上的正确性和稳定性。 建议在开发过程中，针对不同平台进行充分的测试，以验证条件编译代码的预期效果。 powered by Gitbook该文件修订时间： 2025-05-27 05:21:48 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/18.鸿蒙Next案例分析.html":{"url":"chapter3/18.鸿蒙Next案例分析.html","title":"3.18鸿蒙Next案例分析","keywords":"","body":"uniapp/uniappx鸿蒙Next案例分析 本次我们从dcloud官方公布的57个适配鸿蒙应用的案例分析，看看会有哪些发现。 1. 鸿蒙应用开发的行业分布 从提供的57个案例来看，鸿蒙应用已经涵盖了多个行业，以下是一些主要的行业分类： 购物与零售： 莫塞尔商城 海信商城 美好买菜 美的光伏 生活服务与便利： 一码游贵州 黔警通 禾望云 飞蚂蚁旧衣服回收 政务与公共服务： 黔警通 民政通 广州智慧阅读 教育与学习： 睿学在线 少儿围棋教学合集 易智教 医疗与健康： 康强医疗人才网 心灵伙伴云 门诊患者健康风险预警管理平台 企业与办公： 康强医疗人才网 i资源 亲兄弟 娱乐与休闲： 轻糖 曼曼测吧 曼衍照片处理大师 出行与交通： 宁通行 安师傅 众行管家 安全与应急： 地质云 地震预警 太原防汛通 2. 鸿蒙应用的功能特点 从这些应用的功能来看，鸿蒙应用市场中的应用具有以下特点： 多样化功能： 从购物、生活服务到政务、教育、医疗等多个领域，功能覆盖广泛。 例如，美好买菜APP不仅提供生鲜蔬菜、生活日用品等商品购买服务，还提供优惠活动和券后价格实惠的功能。 便捷性与实用性： 许多应用专注于提高用户的生活便利性，如黔警通提供便捷的公安业务办理，飞蚂蚁旧衣服回收提供环保回收服务。 例如，美好买菜APP的用户评论中提到“活动很多，价格很实惠”，显示出其在提供优惠和便利方面的优势。 技术创新与融合： 部分应用结合了物联网、AI等技术，如禾望云提供电站运营分析和移动运维服务，心灵伙伴云提供学生心理健康测评工具。 例如，地质云是由中国地质调查局主持研发的综合性地质信息服务系统，体现了技术的创新与融合。 3. 鸿蒙应用的开发技术 从uni-app开开发技术的角度来看，鸿蒙应用市场中的应用主要分为： 鸿蒙原生应用开发： 鸿蒙原生应用充分利用了鸿蒙系统的特性和优势，如分布式能力、服务卡片等。 鸿蒙元服务： 鸿蒙元服务是一种轻量级的应用形式，用户无需下载即可使用，适合提供即时服务。 例如，塔罗牌占卜师和多点计算器等元服务，用户可以直接在鸿蒙系统的服务卡片中使用，无需下载安装。 4. 鸿蒙应用的生态发展 从这些案例可以看出，鸿蒙应用生态正在逐步扩展和成熟： 行业覆盖广泛： 鸿蒙应用已经覆盖了购物、生活服务、政务、教育、医疗、企业办公、娱乐、出行、安全等多个行业，显示出其在各领域的广泛应用。 开发者参与度高： 从案例中可以看出，不仅有大型企业（如华为、海信、美的等）参与开发，还有许多中小企业和创业公司也在积极开发鸿蒙应用。 用户体验提升： 通过提供多样化、便捷、实用的应用，鸿蒙应用市场不断丰富用户的使用场景，提升用户体验。 技术融合与创新： 鸿蒙应用结合了物联网、AI、大数据等技术，为用户提供全方位的解决方案。 5. 总结与展望 鸿蒙应用市场的发展显示出其在构建全场景分布式操作系统生态方面的积极进展。通过覆盖多个行业和提供多样化功能，鸿蒙应用不仅满足了用户的需求，还推动了技术的融合与创新。未来，随着更多开发者和企业的加入，鸿蒙应用生态有望进一步扩展和深化，为用户带来更多优质的体验和服务。 powered by Gitbook该文件修订时间： 2025-05-21 22:42:21 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/20.热重载.html":{"url":"chapter3/20.热重载.html","title":"3.20热重载","keywords":"","body":"鸿蒙DevEco Studio如何开启热重载 HBuilderX 4.41+ 支持热重载，但跟具体修改的代码文件有关，如果进行了无法热重载的修改，会自动重新安装整个应用并重新运行。 powered by Gitbook该文件修订时间： 2025-05-19 14:12:09 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/21.调用鸿蒙原生组件.html":{"url":"chapter3/21.调用鸿蒙原生组件.html","title":"3.21调用鸿蒙原生组件","keywords":"","body":"调用鸿蒙原生组件 在 WebView 中使用 embed 来渲染原生组件，在 Vue 文件中使用的 embed 组件是经过 uni-app 封装的，更便于使用，支持传递额外的属性和事件。 属性 属性名 类型 说明 tag string 必填，原生组件的标签名 options object 可选，原生组件的属性集合，具体属性请参考原生组件 BuilderOptions 中的定义，更新时需要对 options 重新赋值 事件 所有 embed 组件上注册的事件均会转发到原生层。 示例代码 export default { data() { return { options: { label: 'hello' } } }, methods: { onClick(e) { console.log('onClick', e.detail.text) this.options = { label: 'world' } } } } .native-button { display: block; width: 200px; height: 50px; margin: 10px auto; } 完毕 powered by Gitbook该文件修订时间： 2025-05-19 14:12:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/22.从开发者视角看 uniapp 与 Flutter 的差异.html":{"url":"chapter3/22.从开发者视角看 uniapp 与 Flutter 的差异.html","title":"3.22从开发者视角看 uniapp 与 Flutter 的差异","keywords":"","body":"从开发者视角看 uniapp 与 Flutter 的差异 uniapp 与 Flutter 是当前非常流行的两种跨平台移动应用开发框架。uniapp 是一种使用 Vue.js 开发所有前端应用的框架，可以方便地开发跨平台应用，并可以发布到 Android、iOS、Web、H5、小程序等多个平台。而 Flutter 是由 Google 推出的，基于 Dart 语言的移动应用开发框架，以其强大的性能和流畅的用户体验而闻名。 - uniapp - 基于Vue.js - 支持多平台开发 - 高效开发 - Flutter - 基于Dart语言 - 强大的性能 - 流畅的用户体验 uniapp 开发实战 2.1 创建 uniapp 项目 首先，需要安装 HBuilderX 开发工具，它是 uniapp 的官方推荐工具。 # 安装HBuilderX # (此处省略具体安装步骤) # 创建uniapp项目 # 在HBuilderX中，选择“文件”->“新建”->“项目”->“uni-app” 2.2 编写页面组件 在 uniapp 中，你可以使用 Vue.js 的组件系统来创建和管理页面组件。 {{ title }} export default { data() { return { title: 'Hello, uniapp!' } } } .content { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; } .title { font-size: 24px; font-weight: bold; } 2.3 打包和发布 最后，你可以使用 HBuilderX 的内置工具来打包和发布你的 uniapp 应用到各个平台。 # 在HBuilderX中，选择“发行”->“原生App云打包” # (此处省略具体打包和发布步骤) 3.1 创建 Flutter 项目 首先，你需要安装 Flutter SDK 和 Android Studio，并在 Android Studio 中安装 Flutter 和 Dart 插件。 # 安装Flutter SDK # (此处省略具体安装步骤) # 创建Flutter项目 flutter create myapp 3.2 编写 Flutter 界面 在 Flutter 中，你可以使用 Widget 来构建你的应用界面。 import 'package:flutter/material.dart'; void main() => runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(), ); } } class MyHomePage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Flutter Demo Home Page'), ), body: Center( child: Text('Hello, Flutter!'), ), ); } } 3.3 运行和调试 最后，你可以使用 Flutter 的命令行工具来运行和调试你的 Flutter 应用。 # 进入项目目录 cd myapp # 运行应用 flutter run # 调试应用 flutter debug uniapp 与 Flutter 在核心技术方面存在明显的差异，主要体现在以下几个方面： 框架基础： uniapp：基于 Vue.js 的框架，使用 Vue.js 的语法和组件系统。它的目标是简化跨平台应用的开发，开发者可以使用 Web 技术来开发应用，并方便地发布到多个平台。 Flutter：基于 Dart 语言的框架，拥有自己的 Widget 系统。Flutter 的设计目标是高性能和流畅的用户体验，它提供了丰富的原生控件和强大的布局系统。 性能： uniapp：由于它是基于 Vue.js 的，因此在性能和响应速度上可能不如完全的原生应用。但在一些简单的应用上，uniapp 可以提供足够的性能。 Flutter：Flutter 使用 Dart 语言编译成高效的本地代码，其性能非常接近原生应用。Flutter 的流畅度和性能是其最显著的特点之一。 跨平台机制： uniapp：使用 Web 技术来开发应用，然后通过平台特定的编译器将代码转换为各平台的原生代码。这种方式简化了跨平台开发的复杂性，但可能会牺牲一些性能。 Flutter：Flutter 提供了自己的跨平台机制，使用一套统一的代码基础来构建 iOS 和 Android 应用。Flutter 利用 Dart 语言的跨平台特性，使其能够轻松地构建应用。 生态系统和支持： uniapp：由于它基于 Vue.js，因此可以访问到 Vue.js 丰富的生态系统和插件。此外，uniapp 还有自己的插件市场和社区支持。 Flutter：Flutter 拥有自己的插件市场和社区支持，并且得到了 Google 的官方支持。Flutter 的生态系统非常活跃，并且不断成长。 学习曲线： uniapp：由于它基于 Vue.js，对于熟悉 Vue.js 的开发者来说，学习曲线相对平缓。 Flutter：虽然 Flutter 的学习曲线可能稍微陡峭一些，但它的文档和社区资源非常丰富，有助于开发者快速上手。 综上所述，uniapp 和 Flutter 在核心技术上存在差异，选择哪种框架取决于你的具体需求和偏好。如果你需要开发跨平台应用，并且希望使用 Web 技术，那么 uniapp 可能是一个不错的选择。如果你追求高性能和流畅的用户体验，并且愿意投入更多的学习成本，那么 Flutter 可能更适合你。 在开发环境方面，uniapp 和 Flutter 各自具有其独特的特点和优势。以下是它们之间的一些对比： 集成开发环境（IDE）： uniapp：uniapp 推荐使用 HBuilderX 作为其主要的 IDE。HBuilderX 是一个跨平台的集成开发环境，特别为 uniapp 优化，提供了丰富的功能和插件支持。 Flutter：Flutter 官方推荐使用 Android Studio 作为其主要的 IDE。Android Studio 是 Google 推出的强大的集成开发环境，专为 Android 和 Flutter 开发设计。 编程语言和工具链： uniapp：基于 Vue.js，使用 HTML、CSS 和 JavaScript 进行开发。虽然可以使用其他编程技术，但 Vue.js 是核心。 Flutter：使用 Dart 语言作为主要的编程语言。Dart 是一个强类型、面向对象、函数式、反应式和静态类型的编程语言。 依赖管理： uniapp：通过 npm 或 yarn 进行依赖管理，使用 Web 的 package 管理系统。 Flutter：Flutter 使用其自己的依赖管理系统，通过 flutter pub 命令管理依赖。 模拟器 / 设备测试： uniapp：使用 HBuilderX 的模拟器进行快速开发和测试，但最终的测试通常需要在真机上进行。 Flutter：Flutter 提供了强大的模拟器支持，可以在 Android Studio 或 Visual Studio Code 中直接使用。同时，Flutter 还支持在真机上进行测试和调试。 社区和生态系统： uniapp：有活跃的社区和丰富的插件市场，为开发者提供了大量的资源和支持。 Flutter：Flutter 的社区非常活跃，有大量的教程、示例和第三方库可供选择。同时，Flutter 还得到了 Google 的官方支持。 总的来说，uniapp 和 Flutter 在开发环境方面各有其特点和优势。选择哪种环境取决于你的项目需求、个人喜好以及学习成本等因素。如果你熟悉 Vue.js 并希望使用 Web 技术进行跨平台开发，那么 uniapp 可能是一个好选择。如果你追求高性能和流畅的用户体验，并且愿意学习 Dart 语言和 Flutter 的生态系统，那么 Flutter 可能更适合你。 在性能表现方面，Flutter 和 uniapp 各有其特点和优势。以下是对它们的性能评估： Flutter： 优点 ： 高性能：Flutter 使用 Dart 语言编译成高效的本地代码，其性能非常接近原生应用。Flutter 的流畅度和性能是其最显著的特点之一。 原生渲染：Flutter 使用自己的渲染引擎，能够实现非常流畅和自然的动画效果。 强大的 Widget 系统：Flutter 的 Widget 系统非常强大，能够高效地构建复杂的用户界面。 缺点 ： 学习曲线：Flutter 的学习曲线可能稍微陡峭一些，尤其是对于不熟悉 Dart 语言的开发者。 对特定平台的定制：虽然 Flutter 的跨平台能力很强，但对于某些平台的特定功能和布局，可能需要额外的定制。 uniapp： 优点 ： 跨平台：uniapp 使用 Web 技术来开发应用，并通过平台特定的编译器将代码转换为各平台的原生代码。这种方式简化了跨平台开发的复杂性。 快速开发：由于基于 Vue.js，开发者可以使用熟悉的 Web 技术进行快速开发。 丰富的插件市场：uniapp 有活跃的社区和丰富的插件市场，为开发者提供了大量的资源和支持。 缺点 ： 性能：由于它是基于 Vue.js 的，因此在性能和响应速度上可能不如完全的原生应用。 特定平台功能：虽然 uniapp 提供了跨平台能力，但对于某些平台的特定功能和布局，可能无法完全实现。 总的来说，Flutter 在性能上表现出色，其高性能和流畅的用户体验是其最显著的特点。而 uniapp 则提供了跨平台开发和快速开发的优势。选择哪种框架取决于你的具体需求和偏好。如果你追求高性能和流畅的用户体验，并且愿意投入更多的学习成本，那么 Flutter 可能更适合你。如果你需要开发跨平台应用，并且希望使用 Web 技术，那么 uniapp 可能是一个不错的选择。 请注意，性能评估是一个复杂的问题，受到多种因素的影响，包括应用的复杂性、开发者的技术水平以及测试环境等。因此，在做出选择之前，最好进行实际的性能测试和评估。 在 UI 设计方面，uniapp 和 Flutter 都提供了丰富的 UI 组件和工具，使得开发者可以轻松地构建出美观和易用的界面。然而，它们在 UI 设计方面存在一些差异和特点。 UI 组件库： uniapp：使用基于 Vue.js 的组件系统，可以访问到 Vue.js 丰富的 UI 组件库。此外，uniapp 还有自己的 UI 组件库，并且有丰富的插件市场，提供了更多的 UI 组件和样式选择。 Flutter：Flutter 拥有自己强大的 Widget 系统，提供了丰富的原生控件和强大的布局系统。Flutter 的 UI 组件库非常全面，并且不断成长和更新。 样式和主题： uniapp：使用 CSS 进行样式设计，可以方便地应用样式和主题。uniapp 提供了丰富的样式和主题选择，并且可以方便地自定义。 Flutter：Flutter 使用 Dart 语言进行样式设计，支持多种样式系统，包括 CSS 样式的 Dart 实现和 Flutter 的样式系统。Flutter 的样式和主题非常灵活，可以轻松地定制和扩展。 动画和过渡效果： uniapp：可以使用 CSS3 动画和 JavaScript 的动画库来创建平滑的动画和过渡效果。 Flutter：Flutter 使用自己的动画和过渡系统，可以实现非常流畅和自然的动画效果。Flutter 的动画和过渡效果非常强大和灵活。 响应式设计： uniapp：基于 Web 技术，可以方便地实现响应式设计，适应不同的屏幕大小和分辨率。 Flutter：Flutter 提供了强大的布局系统，可以方便地实现响应式设计。Flutter 的布局系统非常灵活和强大，可以轻松地适应不同的屏幕大小和分辨率。 总的来说，uniapp 和 Flutter 在 UI 设计方面都有丰富的组件和工具，使得开发者可以轻松地构建出美观和易用的界面。选择哪种框架取决于你的具体需求和偏好。如果你熟悉 Vue.js 并希望使用 Web 技术进行跨平台开发，那么 uniapp 可能是一个好选择。如果你追求高性能和流畅的用户体验，并且愿意学习 Flutter 的生态系统，那么 Flutter 可能更适合你。 请注意，UI 设计是一个复杂的问题，受到多种因素的影响，包括设计者的技术水平和创意，以及应用的特定需求。因此，在做出选择之前，最好对 uniapp 和 Flutter 的 UI 设计进行实际的测试和评估。 在社区支持方面，uniapp 和 Flutter 都拥有活跃的社区和丰富的资源，为开发者提供了大量的帮助和支持。以下是它们之间的社区生态比较： 社区活跃度： uniapp：拥有活跃的社区，开发者可以在各种论坛、社区和社交平台上找到大量的讨论和教程。uniapp 的社区非常友好，并且提供了大量的帮助和资源。 Flutter：Flutter 的社区也非常活跃，有大量的教程、示例和第三方库可供选择。Flutter 的社区得到了 Google 的官方支持，因此有更多的资源和指导。 文档和教程： uniapp：uniapp 提供了丰富的官方文档和教程，帮助开发者快速上手。此外，还有大量的第三方教程和指南可供参考。 Flutter：Flutter 的官方文档和教程非常丰富，涵盖了从入门到高级的各个方面。同时，Flutter 的社区也提供了大量的教程和示例。 插件和扩展： uniapp：uniapp 有丰富的插件市场，为开发者提供了大量的资源和工具。开发者可以在插件市场上找到各种各样的插件和扩展。 Flutter：Flutter 的插件市场也非常活跃，有大量的第三方库和插件可供选择。这些插件和库为开发者提供了丰富的功能和扩展。 支持： uniapp：uniapp 的社区提供了大量的支持和帮助，包括论坛、社区和社交平台。开发者可以通过这些渠道获取帮助和解答问题。 Flutter：Flutter 的社区也提供了丰富的支持和帮助，包括官方文档、社区和论坛。此外，Flutter 还得到了 Google 的官方支持，这意味着开发者可以获取更多的官方资源和指导。 总的来说，uniapp 和 Flutter 在社区支持方面都有丰富的资源和友好的社区环境。选择哪种框架取决于你的具体需求和偏好。如果你需要开发跨平台应用，并且希望使用 Web 技术，那么 uniapp 可能是一个不错的选择。如果你追求高性能和流畅的用户体验，并且愿意学习 Flutter 的生态系统，那么 Flutter 可能更适合你。 请注意，社区支持是一个动态的过程，随着时间的推移，社区的活跃度和资源可能会发生变化。因此，在做出选择之前，最好关注官方文档、社区和论坛，以及了解最新的资源和支持。 在部署与兼容性方面，uniapp 和 Flutter 各有其特点和优势。以下是它们之间的部署与兼容性分析： 部署： uniapp：uniapp 提供了多种平台的部署方式，包括 Android、iOS、Web、H5、小程序等。开发者可以使用 HBuilderX 的内置工具来打包和发布应用到各个平台。 Flutter：Flutter 支持 iOS 和 Android 平台的原生应用部署。开发者可以使用 Flutter 的命令行工具来构建和部署应用到各个平台。 兼容性： uniapp：由于基于 Web 技术，uniapp 在跨平台兼容性方面表现出色。然而，由于使用 Web 技术，某些原生功能可能无法完全实现。 Flutter：Flutter 提供了强大的跨平台能力，能够构建高性能的原生应用。然而，对于某些特定平台和设备的兼容性问题，可能需要额外的定制和适配。 总的来说，uniapp 在跨平台部署和兼容性方面表现出色，尤其适合需要开发跨平台应用的开发者。而 Flutter 则提供了高性能的原生应用部署能力，但可能需要更多的自定义和适配。 请注意，部署与兼容性是一个复杂的问题，受到多种因素的影响，包括应用的复杂性、平台的特定功能和设备的兼容性。因此，在做出选择之前，最好进行实际的部署和兼容性测试，以确保应用能够在目标平台上正常运行。 此外，随着技术的发展和平台的更新，uniapp 和 Flutter 的部署和兼容性可能会有所变化。因此，开发者需要关注官方文档和社区资源，以获取最新的信息和指导。 uniapp 与 Flutter 的优缺点及适用场景 uniapp 优点： 跨平台：使用 Web 技术来开发应用，并通过平台特定的编译器将代码转换为各平台的原生代码，实现跨平台开发。 快速开发：基于 Vue.js，开发者可以使用熟悉的 Web 技术进行快速开发。 丰富的插件市场：有活跃的社区和丰富的插件市场，为开发者提供了大量的资源和支持。 缺点： 性能：在性能和响应速度上可能不如完全的原生应用。 特定平台功能：对于某些平台的特定功能和布局，可能无法完全实现。 适用场景： 需要快速开发跨平台应用：uniapp 的快速开发和跨平台能力使其成为首选。 使用 Web 技术熟悉的开发者：由于基于 Vue.js，对于熟悉 Web 技术的开发者来说，uniapp 是一个不错的选择。 Flutter 优点： 高性能：使用 Dart 语言编译成高效的本地代码，性能非常接近原生应用。 原生渲染：使用自己的渲染引擎，能够实现非常流畅和自然的动画效果。 强大的 Widget 系统：提供了丰富的原生控件和强大的布局系统。 缺点： 学习曲线：Flutter 的学习曲线可能稍微陡峭一些，尤其是对于不熟悉 Dart 语言的开发者。 对特定平台的定制：对于某些平台的特定功能和布局，可能需要额外的定制。 适用场景： 追求高性能和流畅的用户体验：Flutter 的高性能和流畅的用户体验使其成为首选。 愿意学习 Dart 语言和 Flutter 的生态系统：对于愿意投入更多的学习成本，并且追求高性能和流畅的用户体验的开发者来说，Flutter 是一个不错的选择。 总结： uniapp 和 Flutter 各有其优点和适用场景。选择哪种框架取决于你的具体需求和偏好。如果你需要快速开发跨平台应用，并且希望使用 Web 技术，那么 uniapp 可能是一个好选择。如果你追求高性能和流畅的用户体验，并且愿意学习 Flutter 的生态系统，那么 Flutter 可能更适合你。同时，需要注意到，性能评估、UI 设计、社区支持和部署与兼容性都是影响选择的重要因素，因此在做出选择之前，最好进行实际的测试和评估。 powered by Gitbook该文件修订时间： 2025-05-19 14:12:25 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/23.uniappforHarmony学习路线.html":{"url":"chapter3/23.uniappforHarmony学习路线.html","title":"3.23uniappforHarmony学习路线","keywords":"","body":"大家好，今天与大家一起交流关于uniappforHarmony的学习路线。 uniapp for Harmony学习路线 大家首先要学习Vue，建议大家学习Vue3，然后学习uniapp，最后再看这个指导。和uts插件鸿蒙开发专题，其实就可以啦。 什么是 Vue？ Vue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。 当然Vue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API。如果大家打算用 Vue 构建完整的单页应用，推荐采用组合式 API + 单文件组件。 Vue基础学完以后，在开发应用的时候也会用到API，那么就可以查看对应的API文档，这里面分为全局 API，组合式 API，选项式 API，内置内容，单文件组件，进阶 API大家按需查看。 Vue学完以后就可以学习uniapp， uni-app uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/飞书/QQ/快手/钉钉/淘宝）、快应用等多个平台。 这里面的学习主要就要从介绍开始学习。然后查看教程，以及对应的全局文件和组件以及API和开发时用到三方库，就要了解插件，因为这里面目前支持鸿蒙的只有uts，所以需要了解UTS uni-app x 是什么 uni-app x，是下一代 uni-app，是一个跨平台应用开发引擎。 uni-app x 是一个庞大的工程，它包括uts语言、uvue渲染引擎、uni的组件和API、以及扩展机制。 uts是一门类ts的、跨平台的、新语言。 uts在iOS平台编译为swift、在Android平台编译为kotlin、在Web和小程序平台编译为js、在鸿蒙next平台上编译为ArkTS。 学习路线 uts 是什么 uts，全称 uni type script，是一门跨平台的、高性能的、强类型的现代编程语言。 它可以被编译为不同平台的编程语言，如： web平台/小程序，编译为JavaScript Android平台，编译为Kotlin iOS平台，编译Swift 鸿蒙OS平台，编译为ArkTS（HBuilderX 4.22+） 学习路线 HarmonyOS HarmonyOS 是新一代智能终端操作系统。 为不同设备的智能化、互联与协同提供了统一的语言。 设备可实现一碰入网，无屏变有屏，操作可视化，一键直达原厂服务等全新功能。 通过简单而智能的服务，实现设备智能化产业升级。 学习地址。 最后希望大家都可以学会uniapp for Harmony，如果遇到问题，也欢迎加群交流，加群联系方式：17752170152 powered by Gitbook该文件修订时间： 2025-05-19 14:12:33 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter4/1.uni-app_x跨平台实战入门：从0到1开发HarmonyOS_5鸿蒙原生应用.html":{"url":"chapter4/1.uni-app_x跨平台实战入门：从0到1开发HarmonyOS_5鸿蒙原生应用.html","title":"4.1 uni-app x 跨平台实战入门：从 0 到 1 开发 HarmonyOS 5 鸿蒙原生应用","keywords":"","body":"uni-app x 跨平台实战入门：从 0 到 1 开发 HarmonyOS 5 鸿蒙原生应用 课程介绍 你将收获 uni-app x 开发原生鸿蒙核心逻辑 多端界面适配思维和代码兼容实战 从 0 到 1 入门完成可上线的跨平台应用 掌握多端应用的开发能力(HarmonyOS Next/Android/iOS/微信小程序/Web) 适用人群 鸿蒙应用开发工程师，想切入跨平台领域； 想学习鸿蒙、小程序开发但缺乏实战案例的技术爱好者； 已学过 uni-app，想要进阶下一代 uni-app x 技术栈的小伙伴； 想要一套代码，同时覆盖多端的移动端开发工程师； 需快速开发多端应用的企业开发者或创业团队。 课程简介 本课程以「随机笑话」为实战案例，全面解析基于 uni-app x 的跨平台开发流程。通过从环境搭建、功能开发到多端适配的全链路实践，学员将掌握 uni-app x 的核心语法、跨平台组件调用、屏幕适配技巧及多端（HarmonyOS Next/Android/iOS/微信小程序/Web）打包部署能力。课程结合华为折叠屏适配、云打包等真实开发场景，侧重实战落地与前沿技术覆盖，助力开发者快速上手跨平台应用开发并积累项目经验。 课程亮点 实战驱动，即学即用： 以完整开源项目为载体，涵盖从需求分析到上线部署的全流程，避免纯理论堆砌，侧重代码实操与问题解决（如折叠屏适配、多端样式兼容）。 多端适配核心技术拆解： 深度解析 uni-app x 跨平台原理，通过华为折叠屏适配、鸿蒙平台签名配置、兼容性处理等实操，掌握不同设备与平台的差异化适配策略。 前沿技术与生态覆盖： 结合鸿蒙（HarmonyOS Next）开发、Uni TypeScript 语法、SCSS 样式预处理等技术，适配当前跨平台开发趋势。 平台兼容性 HarmonyOS NEXT(鸿蒙) ✅ Android(安卓) ✅ iOS(苹果) ✅ 微信小程序 ✅ Web(浏览器) ✅ 运行效果 iPhone 、Android、鸿蒙阔折叠(展开)、微信小程序 iPhone 、Android、鸿蒙阔折叠(折叠)、微信小程序 技术栈 UniApp X Uni TypeScript Vue 3 开发工具 操作系统：MacOS 15.4.1 编辑器：HBuilder X 4.65 鸿蒙开发环境：DevEco Studio 5.0.4 Release 安卓开发环境：Android Studio (version 2024.2) 苹果开发环境：Xcode Version 16.1 (16B40) 浏览器：Chrome 135.0.7049.85 uni-app x uni-app x 简介 uni-app x，是下一代 uni-app，是一个跨平台应用开发引擎，现已支持编译成 HarmonyOS Next 原生应用(4.61+) uni-app x 包括 uvue 渲染引擎、uts 语言、uni的组件和API、以及扩展机制。 uvue 渲染引擎 用 vue3 框架快速编写页面，最终编译为不同平台的、高性能的纯原生界面。 模板式写法 数据双向绑定 组件机制 在 HarmonyOS Next 平台，uni-app x 的工程被整体编译为 ArkTS + ArkUI 代码，本质上是换了 vue 写法的原生鸿蒙应用。 uts 语言 uts 全称 uni typescript，是一门强类型的现代编程语言。支持跨平台，最终会被编译为不同平台的 native语言，如： web/小程序平台，编译为JavaScript 鸿蒙next平台，编译为ArkTS Android平台，编译为Kotlin iOS平台，编译Swift uts 和 ts 很相似，但为了跨端，uts 进行了一些约束和特定平台的增补。详见 uts语言介绍 注意：在 ts 中，常通过 interface 或 type 定义对象类型，但在 uts 中，需使用 type 定义对象类型。因为 interface 在 kotlin 和 swift 中有差异。 uni 组件 ni-app x 的组件主要分三类： 内置基础组件：如 view、text、image、scroll-view、input... 等，详见组件清单 自定义组件：开发者自己通过 vue 语法封装的组件。 uts组件插件：第三方组件，可通过插件市场下载。 准备工作 开发环境准备 下载安装 HBuilderX 编辑器 通过 HbuilderX 创建 uni-app x 项目 项目目录结构 ├─pages 业务页面文件存放的目录 │ └─index │ └─index.uvue index页面 ├─static 存放应用引用的本地静态资源的目录(注意：静态资源只能存放于此) ├─unpackage 非工程代码，一般存放运行或发行的编译结果 ├─index.html H5端页面 ├─main.uts Vue初始化入口文件 ├─App.uvue 应用配置，用来配置App全局样式以及监听 ├─pages.json 配置页面路由、导航条、选项卡等页面类信息 ├─manifest.json 配置应用名称、appid、logo、版本等打包信息 └─uni.scss uni-app内置的常用样式变量 编译运行 安装 uni-app x 编译器插件 编译并运行鸿蒙原生应用 项目实战 效果预览 素材下载 项目图片素材.zip 结构和样式 使用 uni-app x 组件库实现项目基本布局。 布局注意点： view 组件默认是 flex 模式且方向是垂直 column uni-app x 样式不会继承，文字需要用 text 包裹并单独设置字体样式 参考代码： 随机笑话 笑话加载中... 换一个 .container { /* 注意点1: view 默认是 flex，方向是 column */ /* display: flex; */ /* flex-direction: column; */ /* 注意点2：uni-app x 样式不会继承，文字需要用 text 包裹并单独设置字体样式 */ /* font-size: 100rpx; */ flex: 1; justify-content: center; align-items: center; background-color: #f6f6f6; } .card { width: 90%; border-radius: 20rpx; /* 1. 盒子阴影 X 轴偏移量、Y 轴偏移量、模糊半径 和 颜色 */ box-shadow: 0 10rpx 30rpx #a7b3f9; /* iOS 端存在兼容问题，需要主动设置为白色 */ background-color: #fff; } .header { background-color: #1534f5; height: 110rpx; padding: 0 30rpx; /* iOS 端圆角不受父级约束，需要主动设置圆角 */ border-radius: 20rpx 20rpx 0 0; /* 2. 主轴垂直方向居中 */ justify-content: center; /* 3. style 添加 lang=\"scss\" 后，支持类名嵌套 */ /* 4. 文字不能继承，需要给 text 定义类名修改 */ .header-text { font-size: 28rpx; font-weight: 700; color: #fff; } } .scroll-content { padding: 40rpx 30rpx; /* 5. 最小高度 */ min-height: 300rpx; .scroll-content-text { font-size: 30rpx; color: #3204ac; line-height: 45rpx; } } .footer { /* 6. 水平靠右对齐 */ align-items: flex-end; padding-bottom: 20rpx; padding-right: 20rpx; .footer-button { background-color: #1534f5; color: #fff; font-size: 26rpx; border-radius: 50rpx; padding: 6rpx 30rpx; } } 业务逻辑 笑话接口：https://hmajax.itheima.net/api/randjoke 网络请求API：https://doc.dcloud.net.cn/uni-app-x/api/request.html request联网教程：https://doc.dcloud.net.cn/uni-app-x/tutorial/request.html 参考代码： import { ref } from 'vue' const jokeText = ref('笑话加载中...') // 注意：uni-app x 需要用 type 定义对象类型，用 interface 存在兼容问题 type ServiceData = { message : string data : string } function getJoke() { // 通过范型指定后端返回的数据类型 uni.request({ url: 'https://hmajax.itheima.net/api/randjoke', method: 'GET', success: (res) => { // 兼容安卓端类型的写法 const jokeStr = res.data?.data if (jokeStr !== null) { jokeText.value = jokeStr } }, fail: () => { jokeText.value = '数据获取失败，请检查网络...' } }) } 随机笑话 {{ jokeText }} 换一个 生命周期 页面生命周期 页面生命周期：https://doc.dcloud.net.cn/uni-app-x/page.html#lifecycle 组合式 选项式 描述 onLoad onLoad 生命周期回调 监听页面加载 页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。 onPageShow onShow 生命周期回调 监听页面显示 页面显示/切入前台时触发。 onReady onReady 生命周期回调 监听页面初次渲染完成 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 onPageHide onHide 生命周期回调 监听页面隐藏 页面隐藏/切入后台时触发。 如 navigateTo或底部 tab切换到其他页面，应用切入后台等。 onUnload onUnload 生命周期回调 监听页面卸载 页面卸载时触发。如 redirectTo或 navigateBack到其他页面时。 onResize onResize 页面尺寸改变时触发 onBackPress onBackPress 监听页面返回 参考代码： // ...前面代码省略 // 页面加载时 onLoad(() => { // 获取笑话 getJoke() }) 阔折叠屏适配 获取窗口信息：https://doc.dcloud.net.cn/uni-app-x/api/get-window-info.html 注意事项： vh 单位只能用于 微信小程序端 和 Web 端，HarmonyOS、Android、iOS 端均不支持 max-height、min-height 等属性兼容多端只能使用 数字 或 px 单位 效果预览： 参考代码： // ...省略其他代码 // 同步获取窗口信息，返回的单位 px const windowInfo = uni.getWindowInfo() 随机笑话 {{ jokeText }} 换一个 .scroll-content { padding: 40rpx 30rpx; // 5. 最小高度 min-height: 300rpx; // vh 单位只能用于 微信小程序端 和 Web 端，max-height、min-height 只支持 数字 或 px 单位 /* #ifdef MP-WEIXIN || WEB */ max-height: 66vh; /* 最大高度，屏幕高度 66% */ /* #endif */ } 鸿蒙应用签名证书 鸿蒙调试证书，用于真机调试 鸿蒙发布证书，用于发布上架 AGC 平台创建项目和应用 HBuilderX 配置鸿蒙调试证书 鸿蒙签名证书 DevEco Studio Hbuilder 备注 storeFile 私钥库文件 .p12 storePassword 私钥库密码 ······· keyAlias 私钥别名 debugKey / releaseKey keyPassword 私钥密码 ······· profile 签名描述文件 .p7b certpath 证书文件 .cer AGC 平台创建项目和应用 这里步骤较多，请耐心检查每个步骤，直到完成应用创建。 登录AppGallery Connect，点击\"开发与服务\"。 在项目页面中点击\"添加项目\"。 在\"创建项目\"页面中输入项目名称后，点击\"完成\"。 选择\"证书、APP ID和Profile\"，在左侧导航栏选择\"APP ID\"，进入页面后，点击右上角\"新建\"。 鸿蒙调试证书 打开 manifest.json 文件，选择\"鸿蒙App配置\"菜单后，点击调试证书的\"配置\"按钮。 在配置调试证书中，检查\"应用包名\"，\"运行设备\"无误后，点击 \"自动申请调试证书\" 按钮。 鸿蒙发布证书 鸿蒙发布证书不能自动生成，步骤流程较多，请参考视频讲解，耐心检查每个步骤，直到完成配置。 发布证书文件 配置发布证书 发布证书说明 签名描述文件 .p7b 因包含包名信息不能复用，其他证书文件均可在多个项目复用，请牢记私钥别名和密码。 DevEco Studio Hbuilder 备注 storeFile 私钥库文件 .p12 storePassword 私钥库密码 ······· keyAlias 私钥别名 debugKey / releaseKey keyPassword 私钥密码 ······· profile 签名描述文件 .p7b certpath 证书文件 .cer 鸿蒙应用打包和发行 鸿蒙应用本地打包 在配置鸿蒙发布证书后，就可以进行鸿蒙应用本地打包，最终生成一个携带签名信息的 .app 安装包。 鸿蒙应用上架 在 AGC 平台上传携带签名信息的 .app 安装包，请参加视频讲解或者查看官方文档：发布HarmonyOS应用（HarmonyOS NEXT） 安卓应用云打包(补充) 安卓应用可直接使用云证书完成打包，最终生成一个携带签名信息的 .apk 安装包。 用户可把 apk 上架到各个安卓应用商店。 powered by Gitbook该文件修订时间： 2025-05-22 19:41:31 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter6/1.UTS开发鸿蒙插件.html":{"url":"chapter6/1.UTS开发鸿蒙插件.html","title":"6.1 UTS开发鸿蒙插件","keywords":"","body":"了解 UTS 插件是什么 UTS 插件是 uni-app 扩展API的标准插件形式 详情 uts插件在编译到harmonyOS端时会被编译成ArkTS代码。因此编写代码时应注意遵循 uts规范 和 ets规范。 类型差异 any类型 ArkTS内不能使用any类型，但是uts内any用处比较多，因此在编译为ArkTS时，any类型被转为了Object类型。 对象字面量 ArkTS不允许无类型的对象字面量，编写代码时应注意在需要类型时为对象字面量指定类型。如未指定类型，uts会将此对象字面量编译成as UTSJSONObject的形式。 配置uts插件依赖 鸿蒙的库管理工具是ohpm。类似于js的npm，Android的仓储。 鸿蒙的三方sdk封装文件为.har，类似于Android的.aar uts插件的utssdk/app-harmony/config.json文件内可以配置依赖使用鸿蒙的三方库，配置方式如下： { \"dependencies\": { \"@cashier_alipay/cashiersdk\": \"15.8.26\", // ohpm依赖 \"local-deps\": \"./libs/local-deps.har\" // 本地依赖 } } 以上就是开发过程需要注意的一些问题。 powered by Gitbook该文件修订时间： 2025-06-09 21:27:52 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter6/2.开发uts插件.html":{"url":"chapter6/2.开发uts插件.html","title":"6.2 开发uts插件","keywords":"","body":"参考：https://doc.dcloud.net.cn/uni-app-x/plugin/uts-plugin.html uni-appx开发鸿蒙插件示例 新建步骤拆解 右键点击uni_modules目录 -> 新建插件 创建插件 在HBuilder X 中选中你的项目下uni_modules目录，右键选择新建uni_modules插件, 例如 uts-api 选择类型 uts插件 为了避免和插件市场的其他插件冲突，建议起一个自己的插件前缀名称。 uts插件目录结构 package.json package.json 为 uni_modules 插件配置清单文件，负责描述插件的基本配置。 上面是一个默认的清单文件示例,关于 package.json 更多描述详见 插件的目录结构 根目录 index.uts 文件是程序主入口。如果插件根目录下没有 index.uts，则会在编译到不同平台时，寻找分平台的目录下的 index.uts 文件。 比如编译到 app-harmony 平台时，如果 uts 插件根目录没有 index.uts，会寻找 utssdk/app-harmony/index.uts。如果也没有找到，会报错。 当同时存在分平台目录的 index.uts 和根目录 index.uts 时，会优先获取具体的分平台目录。 开发者有多种组织自己代码的方式： 在插件根目录的 index.uts 中写条件编译代码。简单的业务一个文件搞定 在插件根目录 index.uts 中写条件编译，import 分平台的文件 不写根目录的 index.uts，直接在分平台目录写 index.uts。不跨端时，比如只做一个 Android 插件，这样写比较简单 插件对外暴露能力的总入口在 interface.uts ，他与 index.uts的关系是声明和实现的关系 App原生配置 鸿蒙原生配置 app-harmony文件夹存放uts插件编译到鸿蒙时的代码逻辑，目前仅支持uts文件。 目录名/文件名 用途 index.uts 主入口，interface.uts声明的能力在harmony平台下的实现 HBuilderX项目中uts插件目录结构 在 uni-app / uni-app x 的项目工程下，提供了独立的目录 utssdk，来存放 uts 插件。 当然官方更推荐使用 uni_modules 方式，这是更好的包管理方案。 首先确保项目根目录存在 uni_modules 文件夹，如果不存在，需要手动创建一个，目前HB也有创建uni_modules 的指引，还是比较方便的。 编写interface.uts 插件 uts-api 创建完成后，我们需要确定插件对外暴露的 API。 为了多端统一规范的定义对外暴露的接口，获得更好的语法提示和多端一致性约束，标准做法是在 interface.uts 文件中统一定义插件要暴露的 API 类型、 API 的参数类型、返回值类型、错误码类型、错误接口等信息，然后在各端的 index.uts 中做具体的业务实现。 打开 interface.uts 文件，键入下面的源码, 为了方便说明，源码的每个部分的作用都用注释来说明 // 定义 API的参数类型，基本数据类型的参数无需定义，复杂类型参数建议使用自定义type /** * myApi 异步函数的参数，在type里定义函数需要的参数以及api成功、失败的相关回调函数。 */ export type MyApiOptions = { paramA : boolean success ?: (res : MyApiResult) => void fail ?: (res : MyApiFail) => void complete ?: (res : any) => void } // 定义 API 的返回值类型, 基本数据类型的返回值无需特殊定义，复杂类型的参数建议使用自定义type /** * 函数返回结果 * 可以是void, 基本数据类型，自定义type, 或者其他类型。 * [可选实现] */ export type MyApiResult = { fieldA : number, fieldB : boolean, fieldC : string } // 定义 API 对外暴露的错误码，为了更好语法提示和校验效果，建议将错误码用type 定义成联合类型。定义后，使用未指定的错误码将会被警告提示。 // 建议定义的错误码遵循uni错误规范 [详见](https://uniapp.dcloud.net.cn/tutorial/err-spec.html#unierror)。 /** * 错误码 * 根据uni错误码规范要求，建议错误码以90开头，以下是错误码示例： * - 9010001 错误信息1 * - 9010002 错误信息2 */ export type MyApiErrorCode = 9010001 | 9010002; // 定义 API 的错误回调参数类型，这里定义成 interface 并继承 IUniError 是为了遵循统一的 Uni错误码规范。 // 这里开发者只需要指定 errCode 的类型，以便获得更好的语法提和校验效果。 /** * myApi 的错误回调参数 */ export interface MyApiFail extends IUniError { errCode : MyApiErrorCode }; // 定义对外暴露的 API 类型，这里是个异步函数 /* 异步函数定义 */ export type MyApi = (options : MyApiOptions) => void // 定义对外暴露的 API 类型，这里是个同步函数 /* 同步函数定义 */ export type MyApiSync = (paramA : boolean) => MyApiResult 特别注意 interface.uts 是官方推荐的多端一致性的最佳实践，不做强制要求，可以根据自己的实际情况决定是否实现。比如某个插件只有一个平台，不写interface也可以。 interface.uts 文件中定义并 export 的 interface 接口例如 MyApiFail 只能在插件内部的 uts 文件代码中使用，不能在 .uvue 文件中使用插件时导入使用。 至此，我们就完成了 interface 的定义，如果你遵循规范，定义了错误码的类型和错误码的 interface 如 MyApiFail, 那么你还需要在 unierror.uts 文件中对 MyApiFail 这个接口做具体实现。 编写unierror.uts 为了获得更好语法提示和校验效果，我们在 interface.uts 文件中已经定义了错误的类型和错误的接口。但是错误码对应的具体错误信息，以及错误对象的具体实现，都还没有完成。 unierror.uts 文件就是专门用来实现这些的。 打开 unierror.uts 文件, 键入下面的源码。同样为了说明，源码的每个部分的作用都用注释来说明。 // 首先导入在 interface.uts 文件中定义的错误码类型，和错误的类型 import { MyApiErrorCode, MyApiFail } from \"./interface.uts\" /** * 定义错误主题，错误主题是Uni错误码的一个标准字段。 * 注意：错误主题一般为插件名称，每个组件不同，需要使用时请更改。 * [可选实现] */ export const UniErrorSubject = 'uts-api'; /** * 错误信息，定义和错误码对应的语义化的提示信息，为了更好的获取，建议定义成Map类型。 * @UniError * [可选实现] */ export const UTSApiUniErrors : Map = new Map([ /** * 错误码及对应的错误信息 */ [9010001, 'custom error mseeage1'], [9010002, 'custom error mseeage2'], ]); /** * 错误对象的具体使用实现，该实现会在 index.uts代码中创建使用。 * 使用时只需要传入特定的错误码即可完成创建。 */ export class MyApiFailImpl extends UniError implements MyApiFail { override errCode: MyApiErrorCode /** * 错误对象构造函数 */ constructor(errCode : MyApiErrorCode) { super(); this.errSubject = UniErrorSubject; this.errCode = errCode; this.errMsg = UTSApiUniErrors.get(errCode) ?? \"\"; } } 至此我们完成了符合 uni 错误规范的错误码的定义和实现，后面我们就可以去实现插件的具体逻辑了。 Uni错误规范的更多信息详见。 实现接口定义和业务逻辑 分别在插件的 app-android 、app-ios 等目录下打开 index.uts 文件，键入下面的插件源码: harmonyOS /** * 引用鸿蒙系统库，示例如下： * import deviceInfo from \"@ohos.deviceInfo\"; * [可选实现，按需引入] */ /* 引入 interface.uts 文件中定义的变量 */ import { MyApiOptions, MyApiResult, MyApi, MyApiSync } from '../interface.uts'; /* 引入 unierror.uts 文件中定义的变量 */ import { MyApiFailImpl } from '../unierror'; export { MyApiOptions } /** * 引入三方库 * 暂不支持，请留意后续更新 */ /** * 异步方法 * * uni-app项目中（vue/nvue）调用示例： * 1、引入方法声明 import { myApi } from \"@/uni_modules/uts-api\" * 2、方法调用 * myApi({ * paramA: false, * complete: (res) => { * console.log(res) * } * }); * */ export const myApi : MyApi = function (options : MyApiOptions) { if (options.paramA == true) { // 返回数据 const res : MyApiResult = { fieldA: 85, fieldB: true, fieldC: 'some message' }; options.success?.(res); options.complete?.(res); } else { // 返回错误 let failResult = new MyApiFailImpl(9010001); options.fail?.(failResult) options.complete?.(failResult) } } /** * 同步方法 * * uni-app项目中（vue/nvue）调用示例： * 1、引入方法声明 import { myApiSync } from \"@/uni_modules/uts-api\" * 2、方法调用 * myApiSync(true); * */ export const myApiSync : MyApiSync = function (paramA : boolean) : MyApiResult { // 返回数据，根据插件功能获取实际的返回值 const res : MyApiResult = { fieldA: 85, fieldB: paramA, fieldC: 'some message' }; return res; } 使用插件 下面的示例代码为uni-app-x代码 上面的代码，我们完成了一个名为 \"uts-api\" 的UTS 插件，在 uvue 文件中使用该插件的代码示例如下： // 导入要使用的插件 import { myApi, myApiSync, MyApiOptions } from \"@/uni_modules/uts-api\"; methods: { testMyApi() { // 调用异步方法示例 let options = { paramA: false, complete: (res : any) => { console.log(res) } } as MyApiOptions; myApi(options); }, testMyApiSync() { // 调用同步方法示例 console.log(myApiSync(true)) }, } 运行和编译uts插件，需要在HBuilderX的设置中配置Android和iOS的环境，见如下文档： uts插件Android运行配置 uts插件iOS运行配置 开发uts插件，调试、打断点是重要帮手，参考如下文档 uts插件Android Debug uts插件iOS Debug uts插件Harmony Debug 获取电量插件示例 以获取电量为例，介绍uts插件开发步骤 首先在 uni_modules 目录下新建名为 uts-getbatteryinfo 的 uts 插件 在鸿蒙平台目录下，编辑index.uts，键入以下内容。 // index.uts // 引用android api import Context from \"android.content.Context\"; import BatteryManager from \"android.os.BatteryManager\"; import { UTSAndroid } from \"io.dcloud.uts\"; export function getBatteryCapacity(): string { // 获取android系统 application上下文 const context = UTSAndroid.getAppContext(); if (context != null) { const manager = context.getSystemService( Context.BATTERY_SERVICE ) as BatteryManager; const currentLevel: number = manager.getIntProperty( BatteryManager.BATTERY_PROPERTY_CAPACITY ); return '' + currentLevel + '%'; } return \"0%\"; } 至此，我们已经完成一个Android平台上获取电量的原生能力封装。 我们可以在vue页面中这样使用它： import { getBatteryCapacity } from \"@/uni_modules/uts-getbatteryinfo\"; console.log(getBatteryCapacity()) 有些场景下，我们期望 将获取电量的能力封装为 异步的接口，我们可以使用下面的代码 import Context from \"android.content.Context\"; import BatteryManager from \"android.os.BatteryManager\"; import { UTSAndroid } from \"io.dcloud.uts\"; type GetBatteryInfoOptions = { success?: (res: object) => void fail?: (res: object) => void complete?: (res: object) => void } export function getBatteryInfo(options: GetBatteryInfoOptions) { const context = UTSAndroid.getAppContext(); if (context != null) { const manager = context.getSystemService( Context.BATTERY_SERVICE ) as BatteryManager; const level = manager.getIntProperty( BatteryManager.BATTERY_PROPERTY_CAPACITY ); const res = { errCode: 0, errSubject: \"uts-getbatteryinfo\", errMsg: \"getBatteryInfo:ok\", level, isCharging: manager.isCharging() } options.success?.(res) options.complete?.(res) } else { const res = { errCode: 1001, errSubject: \"uts-getbatteryinfo\", errMsg: 'getBatteryInfo:fail getAppContext is null' } options.fail?.(res) options.complete?.(res) } } 对应的使用代码需要调整为： import {getBatteryInfo} from \"@/uni_modules/uts-getbatteryinfo\"; getBatteryInfo({ success(res) { uni.showToast({ title: \"当前电量：\" + res.level + '%', icon: 'none' }); } }) harmonyOS平台 在utssdk目录下创建harmonyOS平台目录app-harmony 在harmonyOS平台目录下，编辑index.uts，键入以下内容，即可完成harmonyOS平台获取电量能力 import batteryInfo from '@ohos.batteryInfo'; import { GetBatteryInfo, GetBatteryInfoOptions, GetBatteryInfoSuccess, GetBatteryInfoResult, GetBatteryInfoSync } from '../interface.uts'; export const getBatteryInfoSync : GetBatteryInfoSync = function () : GetBatteryInfoResult { return { level: batteryInfo.batterySOC, isCharging: batteryInfo.chargingStatus === batteryInfo.BatteryChargeState.ENABLE || batteryInfo.chargingStatus === batteryInfo.BatteryChargeState.FULL, }; } export const getBatteryInfo : GetBatteryInfo = function (options : GetBatteryInfoOptions) { const batteryInfoResult : GetBatteryInfoSuccess = { errMsg: \"getBatteryInfo:ok\", level: batteryInfo.batterySOC, isCharging: batteryInfo.chargingStatus === batteryInfo.BatteryChargeState.ENABLE || batteryInfo.chargingStatus === batteryInfo.BatteryChargeState.FULL, } try { options.success && options.success(batteryInfoResult) } catch (e) { console.error(e) } try { options.complete && options.complete(batteryInfoResult) } catch (e) { console.error(e) } } 以上就是整个的uni-appx开发鸿蒙插件示例，希望可以帮到大家。 powered by Gitbook该文件修订时间： 2025-06-09 21:26:56 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter6/3.新建鸿蒙插件.html":{"url":"chapter6/3.新建鸿蒙插件.html","title":"6.3 新建鸿蒙插件","keywords":"","body":"使用 UTS 调用鸿蒙原生 API 在鸿蒙开发的广阔天地中，UTS（Unified Type System）正以其简洁高效的特性，为开发者带来全新的开发体验。今天，我就来和大家分享一下，如何运用 UTS 轻松调用鸿蒙原生 API，实现各种实用功能。 先来看看核心代码部分： import call from '@ohos.telephony.call'; import common from '@ohos.app.ability.common'; import Want from '@ohos.app.ability.Want'; import { BusinessError } from '@kit.BasicServicesKit'; import batteryInfo from '@ohos.batteryInfo'; import { GetBatteryInfo, GetBatteryInfoOptions, GetBatteryInfoSuccess, GetBatteryInfoResult, GetBatteryInfoSync } from '../interface.uts'; import { scanCore, scanBarcode } from '@kit.ScanKit'; // 导入默认界面需要的日志模块和错误码模块 import { hilog } from '@kit.PerformanceAnalysisKit'; import { BusinessError } from '@kit.BasicServicesKit'; type PhoneType = string; class smsInfo { telephone: PhoneType; constructor(telephone: PhoneType) { this.telephone = telephone } } //打电话 export function makeCall(telephone: PhoneType) { if(!telephone) { console.error(`telephone is required`); return; } call.makeCall(telephone, (err: BusinessError) => { if (err) { console.error(`makeCall fail, err->${JSON.stringify(err)}`); } else { console.log(`makeCall success`); } }); } //发送短信 export function sendSms(telephone: PhoneType, smsContext?: string) { if(!telephone) { console.error(`telephone is required`); return; } let contactInfo: Array = new Array(); contactInfo[0] = new smsInfo(telephone); const context = getContext() as common.UIAbilityContext; let want: Want = { bundleName: 'com.ohos.mms', abilityName: 'com.ohos.mms.MainAbility', parameters: { contactObjects: JSON.stringify(contactInfo), content: smsContext || '', pageFlag: 'conversation' } }; context.startAbility(want) .then(() => { console.info('Succeed to invoke startAbility.'); }) .catch((err: BusinessError) => { console.error(`Failed to startAbility. Code: ${err.code}, message: ${err.message}`); }); } //退出 APP export function exitAPP() { try { let context = getContext() as common.UIAbilityContext; context.terminateSelf((err: BusinessError) => { if (err.code) return; }); } catch (err) { // 捕获同步的参数错误 let code = (err as BusinessError).code; let message = (err as BusinessError).message; console.error(`terminateSelf failed, code is ${code}, message is ${message}`); } } 大家有没有发现，这和 ArkTS 的开发方式有着异曲同工之妙，简洁且直观。 在实际使用中，只需简单地引入相应功能模块，就能快速实现所需功能。例如，添加退出应用方法时，只需如下调用退出应用模块： // 添加退出应用方法 exitApplication() { // 调用退出应用模块 exitAPP(); } UTS 的这种简洁性，大大降低了开发门槛，让开发者能够更高效地利用鸿蒙原生 API 构建应用。无论是调用通讯功能，还是实现应用控制，都能轻松应对。往后，我们将继续深入探索 UTS 的更多特性和应用，为大家带来更多实用的开发技巧和经验分享，助力大家在鸿蒙开发的道路上一往无前！ 什么是uts语言 uts，全称 uni type script，统一、强类型、脚本语言。 它可以被编译为不同平台的编程语言，如： web平台，编译为JavaScript Android平台，编译为Kotlin iOS平台，编译为Swift（HX 3.6.7+ 版本支持） harmonyOS平台，编译为ArkTS（HX 4.22+ 版本支持）在现有架构下，ArkTS和JS在同一环境下执行，不涉及通讯等问题。 明天我们会单独的把这一部分进行详情的讲解，力求大家遇到类似的问题的时候，也能顺利的解决。 powered by Gitbook该文件修订时间： 2025-06-09 21:21:18 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter7/1.开发鸿蒙插件.html":{"url":"chapter7/1.开发鸿蒙插件.html","title":"7.1 开发鸿蒙插件","keywords":"","body":"首先大家需要了解的是发布后的插件，都在https://ext.dcloud.net.cn/ 我们今天来看一下插件的创建流程， 首先新建项目 新建uni_modules目录。 新建后是没有app-harmony目录的，需要自己新建。 然后创建index.uts文件，在里面编写我们的逻辑代码。 发布插件 powered by Gitbook该文件修订时间： 2025-06-09 21:18:20 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter7/2.uniappx插件nutpi-idcard 开发与使用指南（适配鸿蒙）.html":{"url":"chapter7/2.uniappx插件nutpi-idcard 开发与使用指南（适配鸿蒙）.html","title":"7.2 uniappx插件nutpi-idcard开发与使用指南","keywords":"","body":"uniappx插件nutpi-idcard 开发与使用指南（适配鸿蒙） 前言 nutpi-idcard 是一个基于 UTS (uni-app TypeScript Syntax) 开发的 uni-app 插件适配鸿蒙，主要用于解析身份证号码，提取其中的关键信息，如地区、出生日期、性别等。本插件支持中国居民身份证、港澳台居民居住证以及外国人永久居留身份证。 本文将详细介绍 nutpi-idcard 插件的开发过程和使用方法，希望能为其他开发者提供一些参考。 插件功能 身份证号码解析：能够从身份证号码中提取省市区（或国家/地区）、出生日期、性别等信息。 支持多种证件类型： 中国居民身份证 港澳台居民居住证 外国人永久居留身份证 纯 UTS 实现：确保了插件在 uni-app x 及其他支持 UTS 的环境中的兼容性和性能。 跨平台支持：理论上支持所有 uni-app 支持的平台，特别是针对 App (Android, iOS, HarmonyOS) 进行了适配。 开发过程 1. 项目初始化与环境搭建 插件的开发基于 HBuilderX，利用其对 uni-app 和 UTS 的良好支持。 创建 uni-app 项目：首先，创建一个标准的 uni-app 项目（如果还没有的话）。 创建 uni_module：在项目根目录下创建 uni_modules 文件夹（如果不存在），然后在其中创建 nutpi-idcard 文件夹作为插件的根目录。 配置文件 package.json：在 nutpi-idcard 目录下创建 package.json 文件，用于定义插件的基本信息、依赖、平台支持等。关键配置项包括： id: 插件的唯一标识。 displayName: 插件在 HBuilderX 中显示的名称。 version: 插件版本号。 description: 插件描述。 author: 作者信息-坚果派。 contact: 联系方式。 repository: 代码仓库地址。 engines: HBuilderX 版本要求。 dcloudext: DCloud 扩展配置，如插件类型 (uts)、销售信息等。 uni_modules: uni-app 模块配置，如依赖、加密、平台支持等。 2. 核心逻辑实现 (utssdk) 插件的核心代码位于 utssdk 目录下，针对不同平台可以有不同的实现，但本项目中主要关注通用的 UTS 实现，特别是针对 HarmonyOS 的适配。 目录结构： nutpi-idcard/ ├── utssdk/ │ ├── app-harmony/ # HarmonyOS 平台特定代码 │ │ ├── index.uts # HarmonyOS 入口及核心逻辑 │ │ ├── interfaces.uts # TypeScript 接口定义 │ │ └── module/ │ │ └── data/ # 数据文件 (行政区划、国家代码) │ │ ├── china.uts │ │ └── international.uts │ ├── app-android/ # Android 平台 (如果需要特定实现) │ ├── app-ios/ # iOS 平台 (如果需要特定实现) │ ├── index.uts # 插件主入口 (通常导出各平台实现) │ └── interfaces.uts # 通用接口定义 ├── package.json ├── readme.md └── changelog.md 数据准备 (module/data/)： china.uts: 存储中国行政区划代码与名称的映射。 international.uts: 存储 ISO 3166-1 国家代码与名称的映射。 接口定义 (interfaces.uts)： 定义了身份证解析结果的数据结构 IDResult。 export interface IDResult { type?: string; // 证件类型 sign?: string; // 签发机关或地区 country?: string; // 国家或地区 birthday?: string; // 出生日期 (YYYY-MM-DD) sex?: string; // 性别 ('男' 或 '女') isValid?: boolean; // 校验结果 (当前版本简单返回 true) } 核心解析逻辑 (app-harmony/index.uts)： 这是插件的核心，包含了主要的解析函数。 parseID(id: string): IDResult: 公开的 API 函数，根据身份证号码的格式（通过正则表达式判断）调用相应的内部解析函数。 parserChina(id: string): IDResult: 解析中国居民身份证和港澳台居民居住证。 通过身份证号码的前6位确定省市区。 通过第7到14位确定出生日期。 通过第17位（顺序码的最后一位）确定性别。 parserInternational(id: string): IDResult: 解析外国人永久居留身份证。 通过第1到3位（国家或地区代码）和 international.uts 数据确定国家。 通过第7到14位确定出生日期。 通过第17位确定性别。 isIdCardValidInternal(id: string): boolean: 身份证号码有效性校验函数。目前简单返回 true，未来可以根据国家标准实现更复杂的校验逻辑（如校验码计算）。 // idcard/uni_modules/nutpi-idcard/utssdk/app-harmony/index.uts import { chinaData as _china } from './module/data/china.uts'; import { internationalData as _international } from './module/data/international.uts'; import type { IDResult } from './interfaces.uts'; function parserInternational(id: string): IDResult { /* ... */ } function parserChina(id: string): IDResult { /* ... */ } function isIdCardValidInternal(id: string): boolean { /* ... */ } export function parseID(id: string): IDResult { if(id.match(/^9\\d{16}[0-9xX]$/)){ // 外国人永久居留身份证特征 (假设以9开头) return parserInternational(id); }else if(id.match(/^\\d{17}[0-9xX]$/)){ // 中国居民身份证特征 return parserChina(id); }else{ return { type: '未知类型' }; } } 3. 插件入口 (index.uts) 在 nutpi-idcard 根目录下的 index.uts 文件通常作为插件的统一入口，它会根据当前运行平台导出相应平台的 parseID 函数。 // idcard/uni_modules/nutpi-idcard/index.uts // #ifdef APP-HARMONY export * from './utssdk/app-harmony/index.uts'; // #endif // #ifdef APP-PLUS || APP-VUE // 假设 Android 和 iOS 使用相同的 UTS 逻辑，或者有单独的 app-android/index.uts 和 app-ios/index.uts // 如果 utssdk/index.uts 包含了 Android 和 iOS 的通用逻辑，可以这样导出： // export * from './utssdk/index.uts'; // 或者分别导出 // #ifdef APP-ANDROID // export * from './utssdk/app-android/index.uts'; // #endif // #ifdef APP-IOS // export * from './utssdk/app-ios/index.uts'; // #endif // #endif // 默认导出 (如果需要在非特定App平台使用，或者作为H5等平台的兜底) // export * from './utssdk/index.uts'; // 假设 utssdk/index.uts 包含通用或web实现 注意：上述 index.uts 的条件编译部分需要根据实际支持的平台和代码组织来编写。如果主要目标是 HarmonyOS，则 APP-HARMONY 部分是关键。 4. 文档编写 readme.md: 提供插件的详细说明，包括功能特性、安装方法、API 文档、使用示例、作者信息等。 changelog.md: 记录插件的版本更新历史和主要变更。 5. 测试与调试 在 HBuilderX 中创建测试页面，引入插件并调用 parseID 函数，传入不同的身份证号码进行测试。 关注控制台输出，确保解析结果的准确性。 针对不同平台（特别是 HarmonyOS）进行真机或模拟器测试。 遇到的问题与解决 UTS 模块导入路径：UTS 中模块导入路径需要精确。最初可能因为 method.uts 和 index.uts 的拆分导致函数重复声明或找不到定义的问题。通过将 method.uts 的内容合并到 index.uts 中解决了此问题。 Git 推送标签失败：在版本发布时，如果本地没有对应的 Git 标签，git push origin 会失败。通过先执行 git tag 创建本地标签，然后再推送解决。 函数未定义错误：在页面中调用插件函数时，如果导入路径不正确或插件未正确导出函数，会导致 xxx is not defined 错误。仔细检查插件的 index.uts 导出逻辑和页面中的导入路径，确保一致。 如何使用 nutpi-idcard 插件 安装插件： 从 DCloud 插件市场安装。插件地址：https://ext.dcloud.net.cn/plugin?id=23728 或者，如果手动引入，将 nutpi-idcard 整个文件夹复制到你的 uni-app 项目的 uni_modules 目录下。 引入插件：在需要使用的页面或组件的 或 中引入插件。 // 示例：在页面的 中 import { parseID } from '@/uni_modules/nutpi-idcard'; // HBuilderX 会自动处理路径映射 // 如果在 uni-app x 项目的 .uvue 文件中，路径可能需要更明确，或者依赖 HBuilderX 的智能提示 调用解析函数：使用 parseID 函数解析身份证号码。 const idNumber = '110101199003070978'; // 替换为实际的身份证号码 const idInfo = parseID(idNumber); if (idInfo) { console.log('证件类型:', idInfo.type); console.log('签发地/国家:', idInfo.sign ?? idInfo.country); console.log('出生日期:', idInfo.birthday); console.log('性别:', idInfo.sex); console.log('是否有效:', idInfo.isValid); } API 参考 parseID(id: string): IDResult 解析身份证号码并返回包含详细信息的对象。 参数： id: string - 需要解析的身份证号码（18位中国居民身份证，或外国人永久居留身份证等）。 返回值：IDResult 对象，其结构如下： interface IDResult { type?: string; // 证件类型 (例如：'居民身份证', '外国人永久居留身份证', '港澳台居民居住证', '未知类型') sign?: string; // 签发机关或地区信息 (例如：'北京市市辖区', '北京市朝阳区') country?: string; // 国家或地区 (例如：'中国', '无国籍' 或其他国家名称，主要用于外国人身份证) birthday?: string; // 出生日期，格式为 'YYYY-MM-DD' sex?: string; // 性别 ('男' 或 '女') isValid?: boolean; // 身份证号码是否有效 (当前版本简单返回true，待实现详细校验逻辑) } 未来展望 完善校验逻辑：实现更严格的身份证号码校验，包括校验码的计算与验证。 更广泛的证件类型支持：考虑支持更多国家或地区的身份证件类型。 性能优化：对数据查找和字符串处理进行优化，提高解析效率。 更详细的错误提示：当输入格式错误或无法解析时，提供更具体的错误信息。 单元测试：为插件编写完善的单元测试，确保代码质量和稳定性。 作者与联系方式 作者：坚果派 公众号：nutpi 电话：17752170152 官网：https://www.nutpi.net/ 代码仓库：https://gitcode.com/nutpi/uni-idcard 希望这个插件能对您有所帮助！如果您有任何问题或建议，欢迎联系。 相关链接 UTS 语法 UTS API 插件 Hello UTS 插件地址：https://ext.dcloud.net.cn/plugin?id=23728 仓库地址：https://gitcode.com/nutpi/uni-idcard 坚果派 坚果派社区由小波、狼哥等人创建，团队拥有数位华为HDE及1000+HarmonyOS开发者，以及若干其他领域的三十余位万粉博主/UP主运营。 专注于分享的技术包括HarmonyOS/OpenHarmony、仓颉、ArkUI-X、元服务、AI、BlueOS操作系统等。团队成员主要聚集在北京，上海，南京，深圳，广州，苏州、长沙、宁夏等地，目前已为华为、vivo、腾讯、亚马逊以及三方技术社区提供各类开发咨询服务100+。累计粉丝100+w，孵化开发者10w+，高校20+、企业10+。自研应用40款，三方库80个，鸿蒙原生应用课程500+。持续助力鸿蒙仓颉等生态繁荣发展。 powered by Gitbook该文件修订时间： 2025-06-08 21:21:26 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter7/3.chinese-number-format插件.html":{"url":"chapter7/3.chinese-number-format插件.html","title":"7.3 chinese-number-format插件","keywords":"","body":"nutpi-chinese-number-format：强大的中文数字格式化 UTS 插件（适配鸿蒙） 前言 在移动应用开发中，数字的本地化显示是一个常见需求。特别是在中文环境下，我们经常需要将阿拉伯数字转换为中文数字，或者进行相反的转换。今天为大家介绍一个功能强大的 UTS 插件 —— nutpi-chinese-number-format，它专门解决中文数字格式化的各种需求。 插件概述 nutpi-chinese-number-format 是一个专为 uni-app 和 uni-app x 项目设计的中文数字格式化插件。它基于 UTS（UniApp TypeScript）技术开发，提供了完整的 TypeScript 类型定义，确保开发过程中的类型安全。 🌟 核心特性 ✅ 双向转换：支持阿拉伯数字与中文数字之间的双向转换 ✅ 大写支持：支持中文数字大写格式转换（如：壹、贰、叁） ✅ 单位处理：智能处理万、亿等中文数字单位 ✅ 近似表示：支持大数字的近似中文表示 ✅ 月份转换：支持数字月份转中文月份（包括传统月份名称） ✅ 多地区支持：同时支持简体中文（zh-CN）和繁体中文（zh-TW） ✅ 跨平台兼容：支持 App（Android/iOS/Harmony）、H5、小程序等多个平台 ✅ 类型安全：完整的 TypeScript 类型定义 开发过程 我们需要如图方式，先创建项目，选择uniappx，vue3 接下来我们就可以新建uni_modules插件，这里面我们选择uts插件-API插件。 后面就是大家编写代码的过程了，这里面需要注意的是，因为这个插件和平台的关联性不是很大，所以我们在插件的根目录下创建index.uts里面实现我的逻辑就好。 技术架构 UTS 技术优势 该插件采用 UTS（UniApp TypeScript）技术开发，相比传统的 JavaScript 插件具有以下优势： 性能优化：UTS 编译后的代码性能更接近原生 类型安全：完整的 TypeScript 支持，减少运行时错误 跨平台一致性：在不同平台上保持一致的行为 开发体验：更好的 IDE 支持和代码提示 核心算法设计 插件内部采用了高效的映射表设计： // 基本数字映射 const NUMBER_MAPS = { base: { \"0\": [\"0\", \"０\", \"零\", \"〇\"], \"1\": [\"1\", \"１\", \"一\", \"壹\"], \"2\": [\"2\", \"２\", \"二\", \"貳\", \"贰\"], // ... }, \"zh-TW\": { units: [\"\", \"十\", \"百\", \"千\"], bigUnits: [ \"\", \"萬\", \"億\", \"兆\", \"京\", \"垓\", \"秭\", \"穰\", \"溝\", \"澗\", \"正\", \"載\", ], point: \"點\", uppercase: { /* 繁体大写映射 */ }, }, \"zh-CN\": { units: [\"\", \"十\", \"百\", \"千\"], bigUnits: [ \"\", \"万\", \"亿\", \"兆\", \"京\", \"垓\", \"秭\", \"穰\", \"沟\", \"涧\", \"正\", \"载\", ], point: \"点\", uppercase: { /* 简体大写映射 */ }, }, }; 为了优化性能，插件还预计算了反向映射表： // 预计算反向映射表以优化 toNumber 函数性能 const REVERSE_BASE_MAP: Record = {}; for (const numKey in NUMBER_MAPS.base) { NUMBER_MAPS.base[numKey].forEach((charVariant) => { REVERSE_BASE_MAP[charVariant] = numKey; }); } 功能详解 1. 基础数字转换 数字转中文 import { toChinese } from \"@/uni_modules/nutpi-chinese-number-format\"; // 基础转换 const result1 = toChinese(123); // \"一二三\" const result2 = toChinese(123.45); // \"一二三點四五\" // 指定地区 const result3 = toChinese(123, \"zh-CN\"); // \"一二三\" const result4 = toChinese(123.45, \"zh-CN\"); // \"一二三点四五\" 中文转数字 import { toNumber } from \"@/uni_modules/nutpi-chinese-number-format\"; const num1 = toNumber(\"一二三\"); // 123 const num2 = toNumber(\"一二三點四五\"); // 123.45 const num3 = toNumber(\"一萬二千三百四十五\"); // 12345 2. 带单位的中文表示 import { toChineseWithUnits } from \"@/uni_modules/nutpi-chinese-number-format\"; // 自动添加合适的单位 const result1 = toChineseWithUnits(12345); // \"一萬二千三百四十五\" const result2 = toChineseWithUnits(12345, \"zh-CN\"); // \"一万二千三百四十五\" const result3 = toChineseWithUnits(123456789); // \"一億二千三百四十五萬六千七百八十九\" 3. 大写转换 import { toUpperCase } from \"@/uni_modules/nutpi-chinese-number-format\"; // 转换为大写中文数字 const result1 = toUpperCase(\"一二三\"); // \"壹貳參\" const result2 = toUpperCase(\"一二三\", \"zh-CN\"); // \"壹贰叁\" 4. 大数字近似表示 import { toChineseApproximate } from \"@/uni_modules/nutpi-chinese-number-format\"; // 大数字的近似表示 const result1 = toChineseApproximate(123456789); // \"一點二億\" const result2 = toChineseApproximate(123456789, { locale: \"zh-CN\", precision: 2, }); // \"一点二三亿\" 5. 月份转换 import { toChineseMonth } from \"@/uni_modules/nutpi-chinese-number-format\"; // 简单格式 const month1 = toChineseMonth(10); // \"十月\" const month2 = toChineseMonth(11); // \"十一月\" // 传统格式 const month3 = toChineseMonth(1, { format: \"traditional\" }); // \"正月\" const month4 = toChineseMonth(12, { format: \"traditional\", locale: \"zh-CN\", }); // \"腊月\" 实际应用场景 1. 电商应用中的价格显示 // 在商品详情页显示中文价格 const price = 12888; const chinesePrice = toChineseWithUnits(price, \"zh-CN\"); // \"一万二千八百八十八\" 2. 财务应用中的金额大写 // 发票或收据中的金额大写 const amount = \"一万二千三百四十五\"; const uppercaseAmount = toUpperCase(amount, \"zh-CN\"); // \"壹万贰仟叁佰肆拾伍\" 3. 日期选择器中的月份显示 // 传统日历中的月份显示 const months = []; for (let i = 1; i 4. 数据统计中的大数字展示 // 用户量统计的友好显示 const userCount = 1234567; const friendlyCount = toChineseApproximate(userCount, { locale: \"zh-CN\", precision: 1, }); // \"一点二万\" 在 Vue 组件中的完整使用示例 基础转换 数字 {{ originalNumber }} 转中文：{{ chineseNumber }} 中文转数字：{{ convertedNumber }} 带单位转换 {{ largeNumber }} → {{ chineseWithUnits }} 大写转换 {{ chineseText }} → {{ uppercaseText }} 月份转换 {{ currentMonth }}月 → {{ chineseMonth }} 传统格式：{{ traditionalMonth }} import { toChinese, toChineseWithUnits, toNumber, toUpperCase, toChineseApproximate, toChineseMonth, type Locales, } from \"@/uni_modules/nutpi-chinese-number-format\"; // 响应式数据 const originalNumber = ref(12345); const largeNumber = ref(123456789); const chineseText = ref(\"一二三四五\"); const currentMonth = ref(10); // 计算属性 const chineseNumber = computed(() => toChinese(originalNumber.value, \"zh-CN\")); const convertedNumber = computed(() => toNumber(\"一二三四五\")); const chineseWithUnits = computed(() => toChineseWithUnits(largeNumber.value, \"zh-CN\") ); const uppercaseText = computed(() => toUpperCase(chineseText.value, \"zh-CN\")); const chineseMonth = computed(() => toChineseMonth(currentMonth.value)); const traditionalMonth = computed(() => toChineseMonth(currentMonth.value, { format: \"traditional\", locale: \"zh-CN\", }) ); 性能优化 1. 预计算映射表 插件在初始化时预计算了反向映射表，避免了运行时的重复计算： // 预计算反向映射表，提升 toNumber 函数性能 const REVERSE_BASE_MAP: Record = {}; for (const numKey in NUMBER_MAPS.base) { NUMBER_MAPS.base[numKey].forEach((charVariant) => { REVERSE_BASE_MAP[charVariant] = numKey; }); } 2. 高效的字符串处理 在处理大数字时，插件采用了分组处理的方式，提高了转换效率： // 按4位进行分组处理，提高大数字处理效率 const groups = numStr .split(\"\") .reverse() .reduce((acc: string[][], digit: string, i: number) => { const groupIndex = Math.floor(i / 4); if (!acc[groupIndex]) acc[groupIndex] = []; acc[groupIndex].unshift(digit); return acc; }, []); 错误处理和边界情况 1. 输入验证 // toNumber 函数的错误处理 export function toNumber(str: string): number { let numberStr = \"\"; let hasInvalidChar = false; for (const char of str) { const digit = REVERSE_BASE_MAP[char]; if (digit !== undefined) { numberStr += digit; } else { hasInvalidChar = true; break; } } if (hasInvalidChar || numberStr.length === 0) { return NaN; // 转换失败时返回 NaN } // 处理多个小数点的情况 const parts = numberStr.split(\".\"); if (parts.length > 1) { numberStr = parts[0] + \".\" + parts.slice(1).join(\"\"); } return Number(numberStr); } 2. 月份验证 // toChineseMonth 函数的边界检查 export function toChineseMonth( month: number, options: MonthOptions = {} ): string { // 检查月份是否在1到12之间且为整数 if (month 12 || !Number.isInteger(month)) { return \"\"; // 无效月份返回空字符串 } // ... 其他处理逻辑 } 安装和配置 1. 通过 uni_modules 安装 将 nutpi-chinese-number-format 文件夹复制到项目的 uni_modules 目录下 在 HBuilderX 中重新编译项目 2. 环境要求 HBuilderX: 3.6.8 或更高版本 uni-app: 支持 Vue 2 和 Vue 3 uni-app x: 完全支持 平台支持: App（Android/iOS/Harmony）、H5、小程序等 3. TypeScript 配置 如果你的项目使用 TypeScript，插件提供了完整的类型定义： // 类型导入 import type { Locales, Options, MonthOptions, } from \"@/uni_modules/nutpi-chinese-number-format\"; // 使用类型 const locale: Locales = \"zh-CN\"; const options: Options = { locale: \"zh-CN\", precision: 2, }; 最佳实践 1. 地区设置选择 // 根据用户设备语言自动选择地区 const getLocale = (): Locales => { const systemLocale = uni.getSystemInfoSync().language; return systemLocale.includes(\"TW\") || systemLocale.includes(\"HK\") ? \"zh-TW\" : \"zh-CN\"; }; const userLocale = getLocale(); const result = toChinese(123, userLocale); 2. 错误处理 // 安全的数字转换 const safeToNumber = (str: string): number | null => { const result = toNumber(str); return isNaN(result) ? null : result; }; // 使用示例 const userInput = \"一二三\"; const number = safeToNumber(userInput); if (number !== null) { console.log(`转换成功: ${number}`); } else { console.log(\"转换失败，请检查输入格式\"); } 3. 性能优化建议 // 对于频繁调用的场景，可以缓存结果 const numberCache = new Map(); const cachedToChinese = (num: number, locale: Locales = \"zh-CN\"): string => { const key = `${num}_${locale}`; if (numberCache.has(key)) { return numberCache.get(key)!; } const result = toChinese(num, locale); numberCache.set(key, result); return result; }; 总结 nutpi-chinese-number-format 是一个功能全面、性能优秀的中文数字格式化插件。它不仅提供了丰富的转换功能，还具备以下优势： 技术先进：基于 UTS 技术，性能接近原生 功能完整：涵盖了中文数字处理的各种场景 类型安全：完整的 TypeScript 支持 跨平台：支持 uni-app 生态的所有平台 易于使用：简洁的 API 设计，上手容易 性能优化：预计算映射表，高效的算法实现 无论是开发电商应用、财务系统，还是需要中文本地化的其他应用，这个插件都能为你提供可靠的中文数字格式化解决方案。 联系方式 如有问题或建议，请通过以下方式联系： 作者：坚果派 公众号：nutpi 电话：17752170152 官网：https://www.nutpi.net/ Issues：https://gitcode.com/nutpi/uni-chinese-number-format/issues 相关链接 UTS 语法 UTS API 插件 Hello UTS 插件地址：https://ext.dcloud.net.cn/plugin?id=23776 仓库地址：https://gitcode.com/nutpi/uni-chinese-number-format/ 坚果派 坚果派社区由小波、狼哥等人创建，团队拥有数位华为HDE及1000+HarmonyOS开发者，以及若干其他领域的三十余位万粉博主/UP主运营。 专注于分享的技术包括HarmonyOS/OpenHarmony、仓颉、ArkUI-X、元服务、AI、BlueOS操作系统等。团队成员主要聚集在北京，上海，南京，深圳，广州，苏州、长沙、宁夏等地，目前已为华为、vivo、腾讯、亚马逊以及三方技术社区提供各类开发咨询服务100+。累计粉丝100+w，孵化开发者10w+，高校20+、企业10+。自研应用40款，三方库80个，鸿蒙原生应用课程500+。持续助力鸿蒙仓颉等生态繁荣发展。 powered by Gitbook该文件修订时间： 2025-06-08 23:57:14 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter7/4.calendar插件.html":{"url":"chapter7/4.calendar插件.html","title":"7.4 calendar插件","keywords":"","body":"nutpi-calendar中国传统日历相关功能插件（适配鸿蒙） nutpi-calendar 是一个功能强大的 UTS 插件，用于处理公历和农历之间的转换，获取节日信息、节气、生肖、干支纪年等中国传统日历相关功能。旨在为 uni-app 开发者提供一个简单易用且高效的日历解决方案，尤其适用于需要深度集成中国农历功能的应用。 特性 公历转农历：轻松将公历日期转换为详细的农历信息，包括农历年份、月份、日期、是否闰月、生肖、天干地支等。 农历转公历：支持将农历日期反向转换为公历日期。 节日信息：内置公历节日和农历传统节日数据，方便获取指定日期的节日名称。 节气计算：准确计算二十四节气。 自定义节日：支持添加或修改节日信息。 高性能：基于 UTS 实现，保证在 App 端的原生性能。 API 文档 插件导出一个名为 calendar 的对象，包含以下主要方法： solar2lunar(year: number, month: number, day: number): LunarDateInfo 描述：将公历日期转换为农历日期信息。 参数： year: 公历年份 (例如: 2024) month: 公历月份 (1-12) day: 公历日期 (1-31) 返回值 LunarDateInfo 对象，包含： lunarYear: number - 农历年份 lunarMonth: number - 农历月份 lunarDay: number - 农历日期 isLeap: boolean - 是否闰月 lunarYearChn: string - 农历年份中文 (例如: \"甲辰\") lunarMonthChn: string - 农历月份中文 (例如: \"正月\") lunarDayChn: string - 农历日期中文 (例如: \"初一\") animal: string - 生肖 (例如: \"龙\") astro: string - 星座 gzYear: string - 干支年 (例如: \"甲辰\") gzMonth: string - 干支月 gzDay: string - 干支日 solarTerm: string - 当日节气，若无则为空字符串 festival: string - 公历节日，若无则为空字符串 lunarFestival: string - 农历节日，若无则为空字符串 lunar2solar(lunarYear: number, lunarMonth: number, lunarDay: number, isLeapMonth: boolean = false): SolarDateInfo 描述：将农历日期转换为公历日期信息。 参数： lunarYear: 农历年份 lunarMonth: 农历月份 lunarDay: 农历日期 isLeapMonth: boolean (可选, 默认为 false) - 是否为闰月 返回值 SolarDateInfo 对象，包含： year: number - 公历年份 month: number - 公历月份 day: number - 公历日期 weekday: number - 星期几 (0 为周日，1 为周一，以此类推) weekdayChn: string - 星期几中文 getFestival(year: number, month: number, day: number): string 描述：获取指定公历日期的公历节日名称。 参数：同 solar2lunar 返回值：节日名称字符串，若无则为空字符串。 getLunarFestival(lunarYear: number, lunarMonth: number, lunarDay: number): string 描述：获取指定农历日期的农历节日名称。 参数：同 lunar2solar (无需 isLeapMonth) 返回值：节日名称字符串，若无则为空字符串。 setFestival(month: number, day: number, festivalName: string): void 描述：设置或覆盖公历节日。 参数： month: 公历月份 day: 公历日期 festivalName: 节日名称。如果传入空字符串，则表示删除该节日。 setLunarFestival(lunarMonth: number, lunarDay: number, festivalName: string): void 描述：设置或覆盖农历节日。 参数： lunarMonth: 农历月份 lunarDay: 农历日期 festivalName: 节日名称。如果传入空字符串，则表示删除该节日。 getTerm(year: number, month: number, day: number): string 描述：获取指定公历日期的节气名称 (此方法实际通过 solar2lunar 的返回值的 solarTerm 属性获取)。 toGanZhiYear(year: number): string 描述：获取指定公历年份的干支纪年。 getAnimal(year: number): string 描述：获取指定公历年份的生肖。 使用案例 以下是如何在您的 uni-app x 项目中使用 nutpi-calendar 插件： 引入插件 在您的 .uvue 或 .uts 文件中引入插件： import calendar from \"@/uni_modules/nutpi-calendar\"; 调用 API // 在页面的 script 部分 export default { onLoad() { // 公历转农历 const today = new Date(); const lunarDate = calendar.solar2lunar( today.getFullYear(), today.getMonth() + 1, today.getDate() ); console.log( `今天是农历：${lunarDate.lunarYearChn}年 ${lunarDate.lunarMonthChn}${lunarDate.lunarDayChn}` ); console.log(`生肖：${lunarDate.animal}`); if (lunarDate.solarTerm) { console.log(`节气：${lunarDate.solarTerm}`); } if (lunarDate.festival) { console.log(`公历节日：${lunarDate.festival}`); } if (lunarDate.lunarFestival) { console.log(`农历节日：${lunarDate.lunarFestival}`); } // 农历转公历 (例如：查询2024年正月初一的公历日期) const solarDate = calendar.lunar2solar(2024, 1, 1); console.log( `2024年正月初一的公历日期是：${solarDate.year}-${solarDate.month}-${solarDate.day}` ); // 获取指定日期的节日 const christmas = calendar.getFestival(today.getFullYear(), 12, 25); console.log(`12月25日是：${christmas}`); const springFestival = calendar.getLunarFestival(2025, 1, 1); // 查询2025年春节 console.log(`2025年农历正月初一是：${springFestival}`); // 设置自定义节日 calendar.setFestival(10, 24, \"程序员节\"); const programmersDay = calendar.getFestival( today.getFullYear(), 10, 24 ); console.log(`10月24日是：${programmersDay}`); }, }; 版权信息 作者：坚果派 公众号：nutpi 电话：17752170152 官网：https://www.nutpi.net/ 相关链接 UTS 语法 UTS API 插件 Hello UTS 插件地址：https://ext.dcloud.net.cn/plugin?id=23786 仓库地址：https://gitcode.com/nutpi/uni-calendar 坚果派uni-app X插件 nutpi-idcard：用于解析身份证号码，提取其中的关键信息，如地区、出生日期、性别等。支持中国居民身份证、港澳台居民居住证以及外国人永久居留身份证的插件。插件地址：https://ext.dcloud.net.cn/plugin?id=23728，仓库地址：https://gitcode.com/nutpi/uni-idcard。 nutpi-chinese-number-format：一个功能强大的中文数字格式化 UTS 插件，支持数字与中文之间的双向转换，适用于 uni-app 和 uni-app x 项目。插件地址：https://ext.dcloud.net.cn/plugin?id=23776，仓库地址：https://gitcode.com/nutpi/uni-chinese-number-format/。 nutpi-utils：支持鸿蒙的拨打电话，发短信、退出应用、电量获取等功能。插件地址：https://ext.dcloud.net.cn/plugin?id=22525，仓库地址：https://gitcode.com/nutpi/uni-utils。 calendar中国传统日历：nutpi-calendar 是一个功能强大的 UTS 插件，用于处理公历和农历之间的转换，获取节日信息、节气、生肖、干支纪年等中国传统日历相关功能。插件地址：https://ext.dcloud.net.cn/plugin?id=23786，仓库地址：https://gitcode.com/nutpi/uni-calendar。 powered by Gitbook该文件修订时间： 2025-06-09 21:17:16 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter7/5.HBuilderX 中适配鸿蒙插件的安装使用指南.html":{"url":"chapter7/5.HBuilderX 中适配鸿蒙插件的安装使用指南.html","title":"7.5 HBuilderX中适配鸿蒙插件的安装使用指南","keywords":"","body":"HBuilderX 中适配鸿蒙插件的安装使用指南 在开发适配鸿蒙系统的应用时，借助 HBuilderX 的插件能有效提升开发效率，拓展应用功能。本文将详细介绍在 HBuilderX 中使用适配鸿蒙插件的具体方法。 第一步：注册 / 登陆插件市场 首先下载安装HBuilderX ，其次访问 DCloud 插件市场官网：https://ext.dcloud.net.cn/ 。若已有账号，直接使用账号密码或第三方登录方式登陆；若没有账号，点击注册按钮，根据提示完成注册流程。注册成功后，即可进入插件市场，开启插件探索之旅。 第二步：插件下载与安装 这里为大家介绍几款实用的适配鸿蒙插件及其安装步骤： nutpi-utils：该插件支持鸿蒙系统下的拨打电话、发短信、退出应用、电量获取等功能，极大丰富了应用与系统交互的能力。 插件地址：https://ext.dcloud.net.cn/plugin?id=22525 nutpi-idcard：专门用于解析身份证号码，无论是中国居民身份证，还是港澳台居民居住证以及外国人永久居留身份证，都能准确提取其中的地区、出生日期、性别等关键信息。 插件地址：https://ext.dcloud.net.cn/plugin?id=23728 nutpi-chinese-number-format：一款功能强大的中文数字格式化 UTS 插件，支持数字与中文之间的双向转换，在处理金额、日期等文本表述时十分便捷，适用于 uni-app 和 uni-app x 项目。 插件地址：https://ext.dcloud.net.cn/plugin?id=23776 nutpi-calendar：专注于处理公历和农历之间的转换，不仅能获取节日信息、节气，还能提供生肖、干支纪年等中国传统日历相关功能，对于开发传统文化类应用非常实用。 插件地址：https://ext.dcloud.net.cn/plugin?id=23786 找到心仪的插件后，点击插件页面的 “下载插件” 按钮，将插件包保存到本地。随后打开 HBuilderX，在菜单栏中选择 “工具”->“插件安装”，在弹出的插件安装窗口中，点击 “本地安装”，选择刚刚下载的插件包文件，点击 “确定”。安装完成后，在插件列表中会显示已安装的插件，此时选择对应的项目，点击 “导入”，即可完成插件在项目中的安装。 打开之后，选择对应的项目导入，即可安装成功。 第三步：插件使用 插件安装完成后，在项目中引入插件模块，即可使用其提供的功能。以nutpi-utils插件的拨打电话功能为例，在页面的 JavaScript 文件中添加如下代码： import { makePhoneCall } from 'nutpi-utils'; // 假设电话号码为138xxxxxxxx makePhoneCall('138xxxxxxxx').then(() => { console.log('拨打电话成功'); }).catch((error) => { console.error('拨打电话失败：', error); }); 其他插件的使用方法类似，可参考插件文档中的详细说明进行操作。 通过以上步骤，你就可以在 HBuilderX 中顺利使用适配鸿蒙的插件，为你的鸿蒙应用开发增添强大助力。希望本教程能对你有所帮助，快去尝试开发出更优秀的应用吧！所以你学会了吗？ 坚果派 坚果派社区由小波、狼哥等人创建，团队拥有数位华为HDE及1000+HarmonyOS开发者，以及若干其他领域的三十余位万粉博主/UP主运营。了解更多：https://www.nutpi.net/helpDetail?helpTypeId=46863327045749。 专注于分享的技术包括HarmonyOS/OpenHarmony、仓颉、ArkUI-X、元服务、AI、BlueOS操作系统等。团队成员主要聚集在北京，上海，南京，深圳，广州，苏州、长沙、宁夏等地，目前已为华为、vivo、腾讯、亚马逊以及三方技术社区提供各类开发咨询服务100+。累计粉丝100+w，孵化开发者10w+，高校20+、企业10+。自研应用40款，三方库80个，鸿蒙原生应用课程500+。持续助力鸿蒙仓颉等生态繁荣发展。 powered by Gitbook该文件修订时间： 2025-06-14 09:02:46 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter7/OpenHarmony5.0跟华为HarmonyOS之间的应用生态兼容情况.html":{"url":"chapter7/OpenHarmony5.0跟华为HarmonyOS之间的应用生态兼容情况.html","title":"7.6 OpenHarmony与HarmonyOS兼容性","keywords":"","body":"OpenHarmony5.0跟华为HarmonyOS之间的应用生态兼容情况 兼容方面 系统基础与 API 兼容 ：OpenHarmony 5.0 作为华为 HarmonyOS 的基础版本之一，二者在系统底层架构和部分核心 API 上具有高度一致性。所以基础的比如今日头条咨询类的可以方便迁移。 应用框架兼容 ：都支持 ArkUI 这一声明式 UI 开发框架，基于 ArkTS 进行开发，所以使用ArkUI / ArkTS原生开发的又一部分就可以迁移。 部分应用直接运行 ：一些基础的、使用 OpenHarmony 核心 API 开发的应用，在不涉及 HarmonyOS 特定专有功能的情况下，可以在不经修改或仅做少量修改的情况下直接在 HarmonyOS 设备上运行。比如不涉及华为支付。天气服务，华为应用市场服务等。 不兼容方面 专有 API 差异 ：HarmonyOS 包含一些专有 API，如 HMS Core 服务中的账户管理、推送通知等，而 OpenHarmony 中不存在这些 API。若应用在开发过程中使用了这些专有 API，则无法直接在 OpenHarmony 设备上运行。 应用框架差异 ：HarmonyOS 提供了更完整、更丰富的应用框架，包括更多的 UI 组件、服务交互等功能。相比之下，OpenHarmony 的应用框架相对简化，一些在 HarmonyOS 上可用的高级功能或特定组件在 OpenHarmony 中可能不存在或有所不同。 安全机制差异 ：HarmonyOS 在安全方面进行了较多的定制和优化，具有更严格的安全策略和机制，以确保华为设备的安全性和用户体验。而 OpenHarmony 的安全机制相对较为通用和灵活，以适应不同设备和场景的需求。这带来的影响是OpenHarmony 应用在未进行特别配置的情况下，可能无法直接运行。 生态与服务差异 ：HarmonyOS 拥有庞大的用户群体和完善的应用生态，包括华为应用市场中的大量优质应用，以及与华为帐号、云服务等深度融合的生态服务。而 OpenHarmony 的应用生态仍在不断发展和完善中，虽然也有不少应用支持 OpenHarmony，但在数量和质量上与 HarmonyOS 生态相比还存在差距。 powered by Gitbook该文件修订时间： 2025-06-08 21:22:11 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}